<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MC-1000 – Simulador de Pouso (HTML5)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#000; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { max-width: 980px; margin:0 auto; padding:16px; display:grid; gap:12px; }
    .panel { background:#000; border:1px solid #444; border-radius:10px; padding:12px; }
    label { display:block; margin:8px 0 4px; }
    input { width:170px; padding:6px 8px; background:#050505; border:1px solid #777; border-radius:6px; color:#fff; }
    button { padding:8px 10px; border-radius:8px; border:1px solid #999; background:#111; color:#fff; cursor:pointer; }
    button:hover { background:#222; }
    canvas { display:block; width:100%; height:auto; image-rendering: pixelated; background:#000; border:1px solid #fff; border-radius:4px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:end; }
    .hint { margin-top:8px; font-size:0.95rem; opacity:0.95; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:1px 6px; border:1px solid #777; border-radius:6px; background:#111; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="row">
        <div>
          <label>Velocidade do vento (1–50 m/s)</label>
          <input id="windSpeed" type="number" min="1" max="50" value="10" />
        </div>
        <div>
          <label>Direção do vento (0–359 graus)</label>
          <input id="windDir" type="number" min="0" max="359" value="0" />
        </div>
        <div>
          <button id="startBtn">Iniciar voo</button>
        </div>
      </div>
      <div class="hint">
        Controles:
        <span class="kbd">Q</span>/<span class="kbd">E</span> potência,
        <span class="kbd">A</span>/<span class="kbd">D</span> (ou <span class="kbd">Z</span>/<span class="kbd">X</span>) lateral,
        <span class="kbd">W</span>/<span class="kbd">S</span> frontal (invertido).
        No fim: <span class="kbd">S</span> novo voo, <span class="kbd">N</span> parar.
      </div>
    </div>

    <canvas id="screen" width="256" height="192" aria-label="Tela do jogo"></canvas>
  </div>

<script>
(() => {
  const W = 256, H = 192;
  const canvas = document.getElementById("screen");
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = false;

  const PI = Math.PI;
  const C = PI / 180;

  const SIM_HZ = 60;
  const DT = 1 / SIM_HZ;
  const MAX_CATCHUP_STEPS = 6;

  // --- Stability tuning ---
  // Turning: AD change per second is proportional to bank angle (RL).
  // Old code used AD += RL per tick (far too large).
  const TURN_GAIN = 0.12; // (deg/sec) per deg of bank; 30° -> 3.6°/s

  // Engine response rate (per second); used to scale VV dynamics by dt.
  const SPEED_RESPONSE = 1.0;

  // Inertia smoothing + return-to-center
  const MAX_ROLL  = 30;
  const MAX_PITCH = 25;

  const ROLL_ACCEL  = 50;
  const PITCH_ACCEL = 40;
  const ROLL_DAMP   = 7.0;
  const PITCH_DAMP  = 7.75;

  const ROLL_SPRING  = 60;
  const PITCH_SPRING = 52;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const wrap360 = (deg) => {
    deg %= 360;
    if (deg < 0) deg += 360;
    return deg;
  };
  const sgn = (x) => (x < 0 ? -1 : x > 0 ? 1 : 0);
  const rnd = (x) => Math.round(x);

  function clearScreen() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);
  }
  function line(x1, y1, x2, y2) {
    x1 = rnd(x1); y1 = rnd(y1);
    x2 = rnd(x2); y2 = rnd(y2);
    ctx.beginPath();
    ctx.moveTo(x1 + 0.5, y1 + 0.5);
    ctx.lineTo(x2 + 0.5, y2 + 0.5);
    ctx.stroke();
  }
  function circle(cx, cy, r) {
    cx = rnd(cx); cy = rnd(cy);
    ctx.beginPath();
    ctx.arc(cx + 0.5, cy + 0.5, r, 0, Math.PI * 2);
    ctx.stroke();
  }
  function needle(cx, cy, len, aRad) {
    const x2 = cx + len * Math.sin(aRad);
    const y2 = cy - len * Math.cos(aRad);
    line(cx, cy, x2, y2);
  }
  function textCentered(cx, y, s) {
    const w = ctx.measureText(s).width;
    ctx.fillText(s, rnd(cx - w / 2), rnd(y));
  }

  // Liang–Barsky line clipping
  function clipLineToRect(x1, y1, x2, y2, rx, ry, rw, rh) {
    let t0 = 0, t1 = 1;
    const dx = x2 - x1, dy = y2 - y1;
    function clip(p, q) {
      if (p === 0) return q >= 0;
      const r = q / p;
      if (p < 0) { if (r > t1) return false; if (r > t0) t0 = r; }
      else       { if (r < t0) return false; if (r < t1) t1 = r; }
      return true;
    }
    if (
      clip(-dx, x1 - rx) &&
      clip( dx, (rx + rw) - x1) &&
      clip(-dy, y1 - ry) &&
      clip( dy, (ry + rh) - y1)
    ) {
      const nx1 = x1 + t0 * dx, ny1 = y1 + t0 * dy;
      const nx2 = x1 + t1 * dx, ny2 = y1 + t1 * dy;
      return [nx1, ny1, nx2, ny2];
    }
    return null;
  }

  // Polygon clipping (Sutherland–Hodgman) against axis-aligned rectangle
  function clipPolygonRect(poly, xmin, xmax, ymin, ymax) {
    function clipEdge(points, insideFn, intersectFn) {
      const out = [];
      if (!points.length) return out;
      let S = points[points.length - 1];
      for (const E of points) {
        const Ein = insideFn(E);
        const Sin = insideFn(S);
        if (Ein) {
          if (!Sin) out.push(intersectFn(S, E));
          out.push(E);
        } else if (Sin) {
          out.push(intersectFn(S, E));
        }
        S = E;
      }
      return out;
    }

    function intersectX(p1, p2, x) {
      const [x1,y1] = p1, [x2,y2] = p2;
      const dx = x2 - x1;
      if (dx === 0) return [x, y1];
      const t = (x - x1) / dx;
      return [x, y1 + t * (y2 - y1)];
    }
    function intersectY(p1, p2, y) {
      const [x1,y1] = p1, [x2,y2] = p2;
      const dy = y2 - y1;
      if (dy === 0) return [x1, y];
      const t = (y - y1) / dy;
      return [x1 + t * (x2 - x1), y];
    }

    let out = poly.slice();
    out = clipEdge(out, p => p[0] >= xmin, (s,e) => intersectX(s,e,xmin));
    out = clipEdge(out, p => p[0] <= xmax, (s,e) => intersectX(s,e,xmax));
    out = clipEdge(out, p => p[1] >= ymin, (s,e) => intersectY(s,e,ymin));
    out = clipEdge(out, p => p[1] <= ymax, (s,e) => intersectY(s,e,ymax));
    return out;
  }

  function drawPolygon(poly) {
    if (!poly || poly.length < 2) return;
    for (let i = 0; i < poly.length; i++) {
      const a = poly[i];
      const b = poly[(i + 1) % poly.length];
      line(a[0], a[1], b[0], b[1]);
    }
  }

  // --- Game state ---
  let running = false;
  let ended = false;
  let started = false;
  let endMessage = [];

  let PX=0, PY=0, PZ=0;
  let VX=0, VY=0, VZ=0;
  let GX=0, GY=0, GZ=0;
  let VV=0;
  let AD=0;
  let RL=0;
  let PT=0;
  let TC=5;
  let WX=0, WY=0;
  let ST=0;

  let RLv = 0;
  let PTv = 0;

  const RT = 3, TP = 5, WR = 50;

  const keysDown = new Set();

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    // End screen choices: ignore repeats so holding a key won't restart instantly. [web:188]
    if (ended && (k === "s" || k === "n")) {
      if (e.repeat) return; // KeyboardEvent.repeat is true for auto-repeat while held. [web:188][web:189]
      if (k === "s") document.getElementById("startBtn").click();
      else if (k === "n") {
        running = false;
        ended = true;
        endMessage = ["Encerrado.", "Recarregue a página para jogar novamente."];
      }
      return;
    }

    keysDown.add(k);
  });

  window.addEventListener("keyup", (e) => keysDown.delete(e.key.toLowerCase()));

  function computeVX_VY_fromHeading() {
    const RA = AD * C;
    VX = VV * Math.sin(RA);
    VY = VV * Math.cos(RA);
  }

  function stallDive() {
    ST = 1;
    RL = clamp((Math.floor(Math.random() * 21) - 9), -MAX_ROLL, MAX_ROLL);
    PT = clamp((-21 - Math.floor(Math.random() * 5)), -MAX_PITCH, MAX_PITCH);
    RLv = 0;
    PTv = 0;
  }

  function setDemoScreenState() {
    running = false;
    ended = false;
    endMessage = [];
    PX = 0; PY = 0; PZ = 0;
    VV = 0;
    AD = 0; RL = 0; PT = 0;
    RLv = 0; PTv = 0;
    TC = 5;
    WX = 0; WY = 0;
    VX = 0; VY = 0; VZ = 0;
    GX = 0; GY = 0; GZ = 0;
    ST = 0;
    keysDown.clear();
  }

  function resetGame(windSpeed, windDir) {
    ended = false;
    endMessage = [];
    keysDown.clear();

    PX = 0;
    PY = -20000;
    PZ = 2000;
    VV = 150;

    AD = 0;
    RL = 0;
    PT = 0;
    RLv = 0;
    PTv = 0;
    TC = 5;
    ST = 0;

    const X0 = windSpeed / 3;
    const X1 = windDir;
    WY = X0 * Math.cos(X1 * C);
    WX = -X0 * Math.sin(X1 * C);

    computeVX_VY_fromHeading();

    VZ = VV * Math.sin(PT * C) - 10 + VV / 15;
    GZ = VZ;
    GY = VY + WY;
    GX = VX + WX;

    running = true;
  }

  function updateControlsInertia(dt) {
    if (keysDown.has("q")) TC = TC + 0.2 * (TC < 8.8 ? 1 : 0);
    if (keysDown.has("e")) TC = TC - 0.2 * (TC > 0.2 ? 1 : 0);

    let rollIn = 0;
    if (keysDown.has("a") || keysDown.has("z")) rollIn -= 1;
    if (keysDown.has("d") || keysDown.has("x")) rollIn += 1;

    // Pitch: inverted. W pitch down, S pitch up.
    let pitchIn = 0;
    if (keysDown.has("w")) pitchIn -= 1;
    if (keysDown.has("s")) pitchIn += 1;

    const aRoll  = rollIn  * ROLL_ACCEL  - ROLL_SPRING  * (RL / MAX_ROLL)  - ROLL_DAMP  * RLv;
    const aPitch = pitchIn * PITCH_ACCEL - PITCH_SPRING * (PT / MAX_PITCH) - PITCH_DAMP * PTv;

    RLv += aRoll * dt;
    RL  += RLv * dt;

    PTv += aPitch * dt;
    PT  += PTv * dt;

    if (RL >  MAX_ROLL)  { RL =  MAX_ROLL;  RLv *= 0.25; }
    if (RL < -MAX_ROLL)  { RL = -MAX_ROLL;  RLv *= 0.25; }
    if (PT >  MAX_PITCH) { PT =  MAX_PITCH; PTv *= 0.25; }
    if (PT < -MAX_PITCH) { PT = -MAX_PITCH; PTv *= 0.25; }
  }

  function stepPhysics(dt) {
  // --- Update heading first (more stable) ---
  AD = wrap360(AD + RL * TURN_GAIN * dt);

  // --- Stable airspeed model (no VV division, no negative VV) ---
  // Target airspeed grows with throttle and reduces with nose-up pitch.
  // (Tune constants to taste; these keep behavior similar to your original.)
  let VV_target = (TC * 30) - (8 * PT);
  VV_target = clamp(VV_target, 0, 260);

  // First-order response towards target speed
  const k = 1.2 * SPEED_RESPONSE;     // response rate (1/s)
  VV += (VV_target - VV) * k * dt;

  // Hard clamp so it never becomes negative
  VV = Math.max(0, VV);

  if (VV < 30) stallDive();

  // --- Update velocities from the updated heading and airspeed ---
  computeVX_VY_fromHeading();

  VZ = VV * Math.sin(PT * C) - 10 + VV / 15;

  GX = VX + WX;
  GY = VY + WY;
  GZ = VZ;

  // --- Integrate position using the updated velocities ---
  PX += GX * dt;
  PY += GY * dt;
  PZ += GZ * dt;

  if (PZ <= 0) {
    PZ = 0;
    finishLanding();
  }
}

  function finishLanding() {
    // Clear held keys so “S” doesn't immediately restart or keep pitching
    keysDown.clear();

    running = false;
    ended = true;

    const dist = Math.sqrt(PX*PX + PY*PY);

    if (Math.abs(RL) > RT || PT > TP || PT < 0 || VV > 80) {
      endMessage = [
        "LAMENTAMOS INFORMAR QUE O VOO PJ26 SOFREU UM GRAVE ACIDENTE.",
        "NAO HA SOBREVIVENTES."
      ];
    } else if (Math.abs(PX) > WR || Math.abs(PY) > 1000) {
      if (VV < 40) endMessage = ["VOCE POUSOU FORA DA PISTA.", "COMO SUA VELOCIDADE ERA BAIXA, QUASE NADA ACONTECEU."];
      else if (VV < 80) endMessage = ["VOCE POUSOU FORA DA PISTA.", "ENTRE MORTOS E FERIDOS, SALVARAM-SE TODOS."];
      else endMessage = ["VOCE POUSOU FORA DA PISTA.", "NINGUEM SOBREVIVE A UM POUSO NESTA VELOCIDADE."];
    } else {
      endMessage = ["PARABENS!", "ATERRISSAGEM BEM SUCEDIDA."];
    }

    const rpm = Math.floor(TC * 1000);
    endMessage.push("");
    endMessage.push("VALORES RELATIVOS AO POUSO:");
    endMessage.push(`VELOCIDADE DO AR = ${Math.floor(VV)} M/S`);
    endMessage.push(`DISTANCIA        = ${Math.floor(dist)} M`);
    endMessage.push(`INCLINACAO FRONTAL= ${Math.floor(PT)}`);
    endMessage.push(`INCLINACAO LATERAL= ${Math.floor(RL)}`);
    endMessage.push(`ROTACAO DO MOTOR  = ${rpm} RPM`);
    endMessage.push(`DESVIO DA PISTA   = ${Math.floor(PX)} M`);
    endMessage.push(`DIRECAO           = ${Math.floor(AD)} GRAUS`);
    endMessage.push("");
    endMessage.push("VOAR NOVAMENTE? (S/N)");
  }

  function computeRunwayBearingRB() {
    if (!started) return 0;
    if (PY === 0) return 0;
    let RB = Math.atan(PX / PY) / C;
    if (PY > 0) RB += 180;
    if (RB < 0) RB += 360;
    return wrap360(RB);
  }

  // --- TOP WINDOW (unchanged from your current version) ---
  function drawWindowAndRunway() {
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;

    line(10, 0, 245, 0);
    line(245, 0, 245, 80);
    line(245, 80, 10, 80);
    line(10, 80, 10, 0);

    let YC = 33 + PT * 4;
    let X3 = 16, X4 = 239;
    let Y3 = YC + 118 * Math.tan(RL * 2 * C);
    let Y4 = YC - 118 * Math.tan(RL * 2 * C);

    const horizonClip = clipLineToRect(X3, Y3, X4, Y4, 16, 1, 223, 78);
    if (!horizonClip) return;
    [X3, Y3, X4, Y4] = horizonClip;
    line(X3, Y3, X4, Y4);

    if (!started) return;

    const xmin = 16, xmax = 239, ymin = 1, ymax = 79;

    const RB = computeRunwayBearingRB();

    let WB = AD;
    if (AD > 180) WB -= 360;
    if (RB > 180) WB = WB + 360 - RB;
    else WB = WB - RB;

    const d = Math.sqrt((X3 - X4) ** 2 + (Y3 - Y4) ** 2);
    if (!isFinite(d) || d === 0) return;

    const AN = 118 / (60 * d);

    let X7 = (X3 + X4) / 2 + sgn(X3 - X4) + WB * AN * (X3 - X4);
    let Y7 = (Y3 + Y4) / 2 + 2 + WB * AN * (Y3 - Y4);

    if (!isFinite(X7) || !isFinite(Y7)) return;
    X7 = clamp(X7, xmin, xmax);
    Y7 = clamp(Y7, ymin, ymax);

    const pyAbs = Math.max(1, Math.abs(PY));
    let R = (pyAbs < 1000) ? (8 - Y7 / 10) : (4000 / pyAbs);
    R = clamp(R, 0.4, 8);

    const theta = -RL * 2 * C;
    const cs = Math.cos(theta), sn = Math.sin(theta);
    function toScreen(lx, ly) { return [lx * cs - ly * sn + X7, lx * sn + ly * cs + Y7]; }

    const R5 = 5 * R;

    if (R < 1) {
      const p1 = toScreen(0, -2), p2 = toScreen(0, 2);
      const seg = clipLineToRect(p1[0], p1[1], p2[0], p2[1], xmin, ymin, xmax - xmin, ymax - ymin);
      if (seg) line(seg[0], seg[1], seg[2], seg[3]);
      return;
    }

    const yNear = clamp(2 * R5, 8, 140);
    const farHalfW  = Math.max(1, 0.9 * R);
    const nearHalfW = Math.max(2, 3.5 * R);

    const FL = toScreen(-farHalfW, 0);
    const FR = toScreen( farHalfW, 0);
    const NR = toScreen( nearHalfW, yNear);
    const NL = toScreen(-nearHalfW, yNear);

    const clippedPoly = clipPolygonRect([FL, FR, NR, NL], xmin, xmax, ymin, ymax);
    if (clippedPoly.length < 2) return;

    drawPolygon(clippedPoly);

    const dashStep = 5, dashLen = 2;
    for (let ly = 2; ly < yNear; ly += dashStep) {
      const p1 = toScreen(0, ly);
      const p2 = toScreen(0, Math.min(yNear, ly + dashLen));
      const seg = clipLineToRect(p1[0], p1[1], p2[0], p2[1], xmin, ymin, xmax - xmin, ymax - ymin);
      if (seg) line(seg[0], seg[1], seg[2], seg[3]);
    }
  }

  // --- INSTRUMENTS (unchanged from your current version) ---
  function drawInstrumentsAndHUD() {
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;
    ctx.fillStyle = "#fff";

    const yDial = 128;
    const dials = [
      { cx: 35,  top: "AIRSPEED", bot: "BEARING"  },
      { cx: 95,  top: "HORIZ",    bot: "RUNWAY"   },
      { cx: 155, top: "ALTITUDE", bot: "DRIFT"    },
      { cx: 215, top: "RPM",      bot: "DISTANCE" },
    ];

    for (const d of dials) circle(d.cx, yDial, 25);
    for (const d of dials) {
      for (let k = 0; k < 10; k++) {
        const a = k * PI / 5;
        line(d.cx + 21 * Math.sin(a), yDial - 21 * Math.cos(a),
             d.cx + 19 * Math.sin(a), yDial - 19 * Math.cos(a));
      }
    }

    const yTopLabel  = 95;
    const yDialValue = 112;
    const yBotLabel  = 168;
    const yBotValue  = 180;

    ctx.font = "10px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    for (const d of dials) {
      textCentered(d.cx, yTopLabel, d.top);
      textCentered(d.cx, yBotLabel, d.bot);
    }

    const RB = started ? computeRunwayBearingRB() : 0;
    const dist = started ? Math.sqrt(PX*PX + PY*PY) : 0;
    const rpm = Math.floor(TC * 1000);

    ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    textCentered(35,  yDialValue, `${Math.floor(VV)}`);
    textCentered(155, yDialValue, `${Math.floor(PZ)}`);
    textCentered(215, yDialValue, `${rpm}`);

    needle(35, yDial, 15, VV * PI / 200);

    {
      const cx = 95, cy = yDial;
      const r = 18;
      const theta = -RL * 2 * C;
      const dx = Math.cos(theta), dy = Math.sin(theta);
      const x0 = cx, y0 = cy + PT;

      const fx = x0 - cx, fy = y0 - cy;
      const b = 2 * (fx * dx + fy * dy);
      const cc = (fx * fx + fy * fy) - r * r;
      const disc = b * b - 4 * cc;
      if (disc >= 0) {
        const s = Math.sqrt(disc);
        const t1 = (-b - s) / 2;
        const t2 = (-b + s) / 2;
        line(x0 + t1 * dx, y0 + t1 * dy, x0 + t2 * dx, y0 + t2 * dy);
      }

      let x = 81, y = yDial;
      const segs = [[9,0],[5,5],[5,-5],[9,0]];
      for (const [sx, sy] of segs) {
        line(x, y, x + sx, y + sy);
        x += sx; y += sy;
      }
    }

    const TN = started ? (PZ / 1000) : 0;
    const UN = started ? (PZ - 1000 * Math.floor(TN)) : 0;
    needle(155, yDial, 10, TN * PI / 5);
    needle(155, yDial, 15, UN * PI / 500);

    needle(215, yDial, 15, TC * PI / 5);

    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    textCentered(35,  yBotValue, `${Math.floor(started ? AD : 0)}`);
    textCentered(95,  yBotValue, `${Math.floor(RB)}`);
    textCentered(155, yBotValue, `${Math.floor(started ? PX : 0)}`);
    textCentered(215, yBotValue, `${Math.floor(dist)}`);
  }

  function drawEndScreen() {
    ctx.fillStyle = "rgba(0,0,0,0.92)";
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = "#fff";
    ctx.font = "10px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    let y = 18;
    for (const s of endMessage) {
      if (s === "") { y += 6; continue; }
      ctx.fillText(s, 10, y);
      y += 12;
      if (y > H - 10) break;
    }
  }

  function render() {
    clearScreen();
    ctx.strokeStyle = "#fff";
    ctx.fillStyle = "#fff";
    drawWindowAndRunway();
    drawInstrumentsAndHUD();
    if (ended) drawEndScreen();
  }

  let last = performance.now();
  let acc = 0;

  function loop(now) {
    const dtReal = (now - last) / 1000;
    last = now;
    acc += Math.min(dtReal, 0.25);

    let steps = 0;
    while (acc >= DT && steps < MAX_CATCHUP_STEPS) {
      if (running && !ended) {
        updateControlsInertia(DT);
        stepPhysics(DT);
      }
      acc -= DT;
      steps++;
    }

    render();
    requestAnimationFrame(loop);
  }

  document.getElementById("startBtn").addEventListener("click", () => {
    const ws = clamp(parseFloat(document.getElementById("windSpeed").value || "10"), 1, 50);
    const wd = wrap360(parseFloat(document.getElementById("windDir").value || "0"));
    started = true;
    resetGame(ws, wd);
  });

  setDemoScreenState();
  render();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
