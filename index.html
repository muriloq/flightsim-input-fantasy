<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FlightRTSim – C++ Flight Model (HTML5)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#000; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { max-width: 980px; margin:0 auto; padding:16px; display:grid; gap:12px; }
    .panel { background:#000; border:1px solid #444; border-radius:10px; padding:12px; }
    label { display:block; margin:8px 0 4px; }
    input { width:170px; padding:6px 8px; background:#050505; border:1px solid #777; border-radius:6px; color:#fff; }
    button { padding:8px 10px; border-radius:8px; border:1px solid #999; background:#111; color:#fff; cursor:pointer; }
    button:hover { background:#222; }
    .simstage { position: relative; width: 100%; aspect-ratio: 4 / 3; border:1px solid #fff; border-radius:4px; overflow:hidden; background:#000; }
    #three, #screen { position:absolute; inset:0; width:100%; height:100%; display:block; }
    #three { background:#000; }
    #screen { background: transparent; }
    .controlstage { display:none; width:100%; border:1px solid #fff; border-radius:4px; overflow:hidden; background:#000; }
    #controls { width:100%; height:100%; display:block; background:#000; touch-action:none; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:end; }
    .hint { margin-top:8px; font-size:0.95rem; opacity:0.95; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:1px 6px; border:1px solid #777; border-radius:6px; background:#111; }

    /* Mobile: vertical layout (sim above, controls below) */
    @media (pointer: coarse) {
      .wrap { max-width:none; padding:8px; gap:10px; }
      /* Keep 4:3 to avoid stretching (circles must stay circles). */
      .simstage { aspect-ratio: 4 / 3; height:auto; max-height:48vh; }
      .controlstage { display:block; aspect-ratio: 4 / 3; height:auto; max-height:48vh; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="row">
        <div>
          <label>Velocidade do vento (1–50 m/s)</label>
          <input id="windSpeed" type="number" min="1" max="50" value="10" />
        </div>
        <div>
          <label>Direção do vento (0–359 graus)</label>
          <input id="windDir" type="number" min="0" max="359" value="0" />
        </div>
        <div>
          <button id="startBtn">Iniciar voo</button>
        </div>
      </div>
      <div class="hint">
        Controles:
        <span class="kbd">Q</span>/<span class="kbd">E</span> potência,
        <span class="kbd">A</span>/<span class="kbd">D</span> rolagem,
        <span class="kbd">W</span>/<span class="kbd">S</span> arfagem (invertido),
        <span class="kbd">Z</span>/<span class="kbd">C</span> leme,
        <span class="kbd">B</span> freio,
        <span class="kbd">M</span> mudo.
        No fim: <span class="kbd">R</span> reiniciar, <span class="kbd">N</span> parar.
      </div>
    </div>

    <div class="simstage" aria-label="Simulador">
      <canvas id="three" aria-hidden="true"></canvas>
      <canvas id="screen" width="256" height="192" aria-label="Instrumentos do simulador"></canvas>
    </div>
    <div class="controlstage" aria-label="Controles (mobile)">
      <canvas id="controls" width="256" height="192" aria-label="Controles mobile"></canvas>
    </div>
  </div>

  <script src="vendor/three.min.js"></script>
<script>
(() => {
  // Logical resolution (simulation/render layout coordinates).
  // The canvas backing store is resized to match the window and this logical
  // coordinate system is scaled to it.
  const W = 256, H = 192;
  const canvas = document.getElementById("screen");
  const ctx = canvas.getContext("2d", { alpha: true });
  ctx.imageSmoothingEnabled = true;

  // Mobile controls canvas (separate, below sim on mobile)
  const controlsCanvas = document.getElementById("controls");
  const cctx = controlsCanvas ? controlsCanvas.getContext("2d", { alpha: true }) : null;
  if (cctx) cctx.imageSmoothingEnabled = true;

  // Three.js background canvas
  const threeCanvas = document.getElementById("three");
  const IS_MOBILE =
    (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) ||
    /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent || "");
  // Logical pixels: height of 3D window area at the top.
  // Make it bigger on mobile so the outside view uses more of the screen.
  // Keep it above the top-row dial centers so instruments remain over an opaque panel,
  // but allow the 3D view to extend down near the top-row labels.
  const TOP_WINDOW_H = IS_MOBILE ? 125 : 90;

  const PI = Math.PI;
  const C = PI / 180;

  const SIM_HZ = 60;
  const DT = 1 / SIM_HZ;
  const MAX_CATCHUP_STEPS = 6;

  // --- Unit conversions (C++ model tuning is imperial-ish) ---
  const FT_TO_M = 0.3048;
  const M_TO_FT = 1 / FT_TO_M;
  const MPH_TO_MPS = 0.44704;
  const MPS_TO_MPH = 1 / MPH_TO_MPS;
  const MPS_TO_KMH = 3.6;
  const KMH_TO_MPH = 1 / 1.609344;
  const RPM_MAX = 3000;
  const RPM_IDLE = 50;
  // Low-speed handling helpers:
  // The core model scales control torque with airspeed; at very low speeds this can feel
  // unresponsive. We apply a small "effective airspeed" floor *only* for control authority.
  const CTRL_EFF_SPEED_MPH_MIN = 60; // ~97 km/h
  const randSigned = () => (Math.random() * 2 - 1);
  const randMul = (pct) => 1 + randSigned() * pct;
  const G_MPS2 = 9.80665;

  // --- Control effectiveness tuning (ported model was tuned for a different sim/context) ---
  // Lower values = slower response.
  // Requested tuning: elevator 2x slower, ailerons 5x slower (relative to previous values).
  const AILERON_GAIN = 0.25;  // reduce roll authority (was 0.4)
  const ELEVATOR_GAIN = 0.75; // 1.5 / 2
  const RUDDER_GAIN = 0.16;   // smoother yaw authority from rudder (Z/C)

  // --- Lateral-directional stability tuning (GA-like, approximated) ---
  // Units are chosen to shape the existing deltaVect integrator without introducing β/p/r states.
  // Roll mode: fast roll-rate damping (1–3s) + slow wings-level tendency (weakly stable spiral).
  const ROLL_RATE_DAMP = 2.0;       // 1/s (strong roll rate decay)
  const BANK_LEVEL_SLOW = 0.015;    // 1/s (tens of seconds back toward wings-level)
  const BANK_LEVEL_FAST = 0.035;    // 1/s extra for larger banks (still gentle)

  // Dutch roll feel: yaw↔roll rate coupling with damping so it dies out in a few cycles.
  const DUTCH_K_YAW_FROM_ROLLRATE = 0.55; // 1/s (roll rate excites yaw rate)
  const DUTCH_K_ROLL_FROM_YAWRATE = 0.22; // 1/s (yaw rate excites roll rate via dihedral effect)
  const YAW_RATE_DAMP = 0.55;             // 1/s (yaw rate damping)

  // Adverse yaw: aileron deflection produces yaw opposite the roll direction.
  const ADVERSE_YAW_GAIN = 0.55;          // scalar (applied like other control torques)
  // Rendering-only scaling to make the visible pitch attitude a bit less aggressive.
  // (Does not affect the underlying flight model.)
  const PITCH_RENDER_SCALE = 0.85;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const wrap360 = (deg) => {
    deg %= 360;
    if (deg < 0) deg += 360;
    return deg;
  };
  const sgn = (x) => (x < 0 ? -1 : x > 0 ? 1 : 0);
  const rnd = (x) => Math.round(x);

  // --- Audio (procedural engine + wind) ---
  // Audio must be started/resumed from a user gesture in many browsers.
  let audioCtx = null;
  let audioEngine = null;
  let audioOut = null;      // mute-controlled gain
  let audioMuted = false;
  let audioStopTimer = 0;

  function makeNoiseNode(audioCtx) {
    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;

    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.loop = true;
    return src;
  }

  function softClipCurve(amount = 2.5, n = 2048) {
    const curve = new Float32Array(n);
    for (let i = 0; i < n; i++) {
      const x = (i / (n - 1)) * 2 - 1;
      curve[i] = Math.tanh(amount * x);
    }
    return curve;
  }

  function createCockpitGAPiston(audioCtx, { blades = 2, destination } = {}) {
    // Master out, then cabin low-pass (muffling) into provided destination.
    const master = audioCtx.createGain();
    master.gain.value = 0.75;

    const cabinLP = audioCtx.createBiquadFilter();
    cabinLP.type = "lowpass";
    cabinLP.frequency.value = 950;
    cabinLP.Q.value = 0.65;

    master.connect(cabinLP);
    cabinLP.connect(destination || audioCtx.destination);

    // --- Prop tonal (harmonic stack at multiples of blade-pass frequency) ---
    const propSum = audioCtx.createGain();
    const propDrive = audioCtx.createWaveShaper();
    propDrive.curve = softClipCurve(3.0);

    const propLP = audioCtx.createBiquadFilter();
    propLP.type = "lowpass";
    propLP.frequency.value = 2200;
    propLP.Q.value = 0.4;

    propSum.connect(propDrive);
    propDrive.connect(propLP);
    propLP.connect(master);

    const partialCount = 10;
    const partials = [];
    const partialGains = [];

    for (let i = 0; i < partialCount; i++) {
      const k = i + 1;
      const o = audioCtx.createOscillator();
      o.type = "sine";

      const g = audioCtx.createGain();
      g.gain.value = 0;

      o.connect(g);
      g.connect(propSum);

      o.start();
      partials.push({ k, o });
      partialGains.push(g);
    }

    // --- Cabin resonance (panel/structure drone) ---
    const cabinRes = audioCtx.createBiquadFilter();
    cabinRes.type = "bandpass";
    cabinRes.frequency.value = 180;
    cabinRes.Q.value = 7.0;

    const cabinResGain = audioCtx.createGain();
    cabinResGain.gain.value = 0.0;

    propSum.connect(cabinRes);
    cabinRes.connect(cabinResGain);
    cabinResGain.connect(master);

    // --- Intake/Exhaust coloration (bandpass stacks) ---
    const intakeBP = audioCtx.createBiquadFilter();
    intakeBP.type = "bandpass";
    intakeBP.frequency.value = 650;
    intakeBP.Q.value = 1.2;

    const exhaustBP = audioCtx.createBiquadFilter();
    exhaustBP.type = "bandpass";
    exhaustBP.frequency.value = 220;
    exhaustBP.Q.value = 1.6;

    const intakeGain = audioCtx.createGain();
    intakeGain.gain.value = 0.0;
    const exhaustGain = audioCtx.createGain();
    exhaustGain.gain.value = 0.0;

    propSum.connect(intakeBP);
    intakeBP.connect(intakeGain);
    intakeGain.connect(master);

    propSum.connect(exhaustBP);
    exhaustBP.connect(exhaustGain);
    exhaustGain.connect(master);

    // --- Wind/vent/airframe bed (dark, filtered noise) ---
    const noise = makeNoiseNode(audioCtx);

    const windHP = audioCtx.createBiquadFilter();
    windHP.type = "highpass";
    windHP.frequency.value = 220;
    windHP.Q.value = 0.7;

    const windBP = audioCtx.createBiquadFilter();
    windBP.type = "bandpass";
    windBP.frequency.value = 800;
    windBP.Q.value = 0.8;

    const windGain = audioCtx.createGain();
    windGain.gain.value = 0.0;

    noise.connect(windHP);
    windHP.connect(windBP);
    windBP.connect(windGain);
    windGain.connect(master);

    noise.start();

    // --- Optional subtle engine underlay ---
    const engOsc = audioCtx.createOscillator();
    engOsc.type = "sawtooth";
    const engGain = audioCtx.createGain();
    engGain.gain.value = 0.0;

    const engLP = audioCtx.createBiquadFilter();
    engLP.type = "lowpass";
    engLP.frequency.value = 520;
    engLP.Q.value = 0.5;

    engOsc.connect(engGain);
    engGain.connect(engLP);
    engLP.connect(master);
    engOsc.start();

    // --- Roughness: slow random-ish modulation for uneven combustion/vibration ---
    // LFO -> master.gain (very subtle)
    const roughLFO = audioCtx.createOscillator();
    roughLFO.type = "sine";
    roughLFO.frequency.value = 0.6;
    const roughGain = audioCtx.createGain();
    roughGain.gain.value = 0.03;
    roughLFO.connect(roughGain);
    roughGain.connect(master.gain);
    roughLFO.start();

    // Noise -> lowpass -> gain -> propSum.gain (subtle flutter)
    const roughNoise = makeNoiseNode(audioCtx);
    const roughLP = audioCtx.createBiquadFilter();
    roughLP.type = "lowpass";
    roughLP.frequency.value = 1.5;
    roughLP.Q.value = 0.7;
    const roughNoiseGain = audioCtx.createGain();
    roughNoiseGain.gain.value = 0.02;
    roughNoise.connect(roughLP);
    roughLP.connect(roughNoiseGain);
    roughNoiseGain.connect(propSum.gain);
    roughNoise.start();

    // Modulate intake/exhaust band centers a bit (adds motion/texture)
    const bandLFO1 = audioCtx.createOscillator();
    bandLFO1.type = "sine";
    bandLFO1.frequency.value = 0.10;
    const bandLFO1Gain = audioCtx.createGain();
    bandLFO1Gain.gain.value = 120; // Hz
    bandLFO1.connect(bandLFO1Gain);
    bandLFO1Gain.connect(intakeBP.frequency);
    bandLFO1.start();

    const bandLFO2 = audioCtx.createOscillator();
    bandLFO2.type = "triangle";
    bandLFO2.frequency.value = 0.07;
    const bandLFO2Gain = audioCtx.createGain();
    bandLFO2Gain.gain.value = 60; // Hz
    bandLFO2.connect(bandLFO2Gain);
    bandLFO2Gain.connect(exhaustBP.frequency);
    bandLFO2.start();

    function setBlades(n) { blades = Math.max(1, Math.round(n)); }

    function setState({ rpm = 2400, throttle = 0.7, airspeed = 30 } = {}) {
      const t = audioCtx.currentTime;
      throttle = clamp01(throttle);

      // Blade-pass frequency model.
      const bpf = blades * rpm / 60;

      // Prop tonal: partials at k * BPF, with spectral tilt.
      for (let i = 0; i < partialCount; i++) {
        const k = partials[i].k;
        const targetF = Math.max(10, bpf * k);
        partials[i].o.frequency.setTargetAtTime(targetF, t, 0.02);

        const tilt = 1 / Math.pow(k, 1.12);
        const level = (0.10 + 0.40 * throttle) * tilt;
        partialGains[i].gain.setTargetAtTime(level, t, 0.035);
      }

      // Cabin muffling/brightness (cockpit is darker than outside).
      cabinLP.frequency.setTargetAtTime(750 + 900 * throttle, t, 0.08);
      propLP.frequency.setTargetAtTime(1200 + 2200 * throttle, t, 0.06);

      // Resonance tied to throttle for “drone”.
      cabinRes.frequency.setTargetAtTime(150 + 110 * throttle, t, 0.09);
      cabinResGain.gain.setTargetAtTime(0.02 + 0.12 * throttle, t, 0.09);

      // Intake/exhaust coloration tied to throttle (kept subtle).
      intakeGain.gain.setTargetAtTime(0.01 + 0.10 * throttle, t, 0.10);
      exhaustGain.gain.setTargetAtTime(0.01 + 0.08 * throttle, t, 0.10);

      // Wind bed.
      const v = Math.max(0, airspeed);
      const wind = clamp01(v / 70) * (0.25 + 0.75 * throttle);
      windGain.gain.setTargetAtTime(0.01 + 0.14 * wind, t, 0.12);
      windHP.frequency.setTargetAtTime(160 + 260 * wind, t, 0.12);
      windBP.frequency.setTargetAtTime(550 + 900 * wind, t, 0.12);

      // Engine underlay.
      engOsc.frequency.setTargetAtTime(55 + rpm / 40, t, 0.05);
      engGain.gain.setTargetAtTime(0.008 + 0.05 * throttle, t, 0.08);
    }

    function stop() {
      partials.forEach(p => p.o.stop());
      noise.stop();
      engOsc.stop();
      roughLFO.stop();
      roughNoise.stop();
      bandLFO1.stop();
      bandLFO2.stop();
    }

    return { setState, setBlades, stop };
  }

  function ensureAudioStarted() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (!audioOut) {
      audioOut = audioCtx.createGain();
      audioOut.gain.value = 1.0;
      audioOut.connect(audioCtx.destination);
    }
    // resume() returns a promise; safe to fire-and-forget
    if (audioCtx.state !== "running") audioCtx.resume().catch(() => {});
  }

  function setMuted(nextMuted) {
    audioMuted = !!nextMuted;
    if (!audioCtx || !audioOut) return;
    const t = audioCtx.currentTime;
    audioOut.gain.cancelScheduledValues(t);
    audioOut.gain.setTargetAtTime(audioMuted ? 0.0 : 1.0, t, 0.03);
  }

  function startEngineAudio() {
    ensureAudioStarted();
    if (!audioCtx) return;
    if (audioStopTimer) { clearTimeout(audioStopTimer); audioStopTimer = 0; }
    if (audioEngine) {
      try { audioEngine.stop(); } catch {}
      audioEngine = null;
    }
    audioEngine = createCockpitGAPiston(audioCtx, { blades: 2, destination: audioOut });
    setMuted(audioMuted);
  }

  function stopEngineAudio() {
    if (!audioCtx || !audioOut || !audioEngine) return;
    const t = audioCtx.currentTime;
    audioOut.gain.cancelScheduledValues(t);
    audioOut.gain.setTargetAtTime(0.0, t, 0.06);
    const engineToStop = audioEngine;
    audioEngine = null;
    audioStopTimer = setTimeout(() => {
      try { engineToStop.stop(); } catch {}
      // Restore gain for next start (mute state will reapply).
      if (audioOut && audioCtx) {
        const tt = audioCtx.currentTime;
        audioOut.gain.cancelScheduledValues(tt);
        audioOut.gain.setTargetAtTime(audioMuted ? 0.0 : 1.0, tt, 0.03);
      }
    }, 200);
  }

  // --- Three.js world (terrain + runway) ---
  const USE_THREE_WORLD = true;
  let three = null;
  let TERRAIN_SEED = (Date.now() ^ ((Math.random() * 0xffffffff) >>> 0)) >>> 0;

  function mulberry32(seed) {
    let a = seed >>> 0;
    return function() {
      a |= 0;
      a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function diamondSquare(size, { seed = 1337, roughness = 0.75 } = {}) {
    // size must be 2^n + 1 (e.g., 257). Returns Float32Array(size*size).
    const rand = mulberry32(seed);
    const h = new Float32Array(size * size);
    const idx = (x, y) => y * size + x;

    const set = (x, y, v) => { h[idx(x, y)] = v; };
    const get = (x, y) => h[idx(x, y)];

    // init corners
    set(0, 0, rand());
    set(size - 1, 0, rand());
    set(0, size - 1, rand());
    set(size - 1, size - 1, rand());

    let step = size - 1;
    let scale = 1.0;
    while (step > 1) {
      const half = step / 2;

      // diamond step
      for (let y = half; y < size - 1; y += step) {
        for (let x = half; x < size - 1; x += step) {
          const a = get(x - half, y - half);
          const b = get(x + half, y - half);
          const c = get(x - half, y + half);
          const d = get(x + half, y + half);
          const avg = (a + b + c + d) * 0.25;
          set(x, y, avg + (rand() * 2 - 1) * scale);
        }
      }

      // square step
      for (let y = 0; y < size; y += half) {
        for (let x = (y / half) % 2 === 0 ? half : 0; x < size; x += step) {
          let sum = 0;
          let cnt = 0;
          if (x - half >= 0) { sum += get(x - half, y); cnt++; }
          if (x + half < size) { sum += get(x + half, y); cnt++; }
          if (y - half >= 0) { sum += get(x, y - half); cnt++; }
          if (y + half < size) { sum += get(x, y + half); cnt++; }
          const avg = sum / cnt;
          set(x, y, avg + (rand() * 2 - 1) * scale);
        }
      }

      step = half;
      scale *= roughness;
    }

    // normalize 0..1
    let min = Infinity, max = -Infinity;
    for (let i = 0; i < h.length; i++) { if (h[i] < min) min = h[i]; if (h[i] > max) max = h[i]; }
    const inv = 1 / (max - min || 1);
    for (let i = 0; i < h.length; i++) h[i] = (h[i] - min) * inv;
    return h;
  }

  // --- 2D Perlin noise + fractal Brownian motion (fBm) heightmap ---
  function makePermTable(seed) {
    // Deterministic permutation table using mulberry32.
    const rand = mulberry32(seed);
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    for (let i = 255; i > 0; i--) {
      const j = (rand() * (i + 1)) | 0;
      const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
    }
    const perm = new Uint8Array(512);
    for (let i = 0; i < 512; i++) perm[i] = p[i & 255];
    return perm;
  }

  function fade(t) {
    // Perlin fade curve 6t^5-15t^4+10t^3
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  function lerp(a, b, t) { return a + (b - a) * t; }

  function grad2(hash, x, y) {
    // 8-ish directional gradients
    switch (hash & 7) {
      case 0: return  x + y;
      case 1: return -x + y;
      case 2: return  x - y;
      case 3: return -x - y;
      case 4: return  x;
      case 5: return -x;
      case 6: return  y;
      default: return -y;
    }
  }

  function perlin2D(x, y, perm) {
    const xi = Math.floor(x) & 255;
    const yi = Math.floor(y) & 255;
    const xf = x - Math.floor(x);
    const yf = y - Math.floor(y);

    const u = fade(xf);
    const v = fade(yf);

    const aa = perm[perm[xi] + yi];
    const ab = perm[perm[xi] + yi + 1];
    const ba = perm[perm[xi + 1] + yi];
    const bb = perm[perm[xi + 1] + yi + 1];

    const x1 = lerp(grad2(aa, xf, yf),     grad2(ba, xf - 1, yf),     u);
    const x2 = lerp(grad2(ab, xf, yf - 1), grad2(bb, xf - 1, yf - 1), u);
    // Roughly in [-1, 1]
    return lerp(x1, x2, v);
  }

  function fbm2D(x, y, {
    perm,
    octaves = 6,
    lacunarity = 2.0,
    persistence = 0.5,
    baseFreq = 0.0018,
    baseAmp = 1.0,
  }) {
    let freq = baseFreq;
    let amp = baseAmp;
    let sum = 0;
    let norm = 0;
    for (let i = 0; i < octaves; i++) {
      sum += perlin2D(x * freq, y * freq, perm) * amp;
      norm += amp;
      freq *= lacunarity;
      amp *= persistence;
    }
    return sum / (norm || 1); // ~[-1, 1]
  }

  function fractalHeightmap(size, {
    seed = 1337,
    octaves = 7,
    lacunarity = 2.05,
    persistence = 0.52,
    baseFreq = 0.0016,
  } = {}) {
    // Returns Float32Array(size*size) normalized 0..1.
    const perm = makePermTable(seed);
    const h = new Float32Array(size * size);

    let min = Infinity, max = -Infinity;
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const v = fbm2D(x, y, { perm, octaves, lacunarity, persistence, baseFreq });
        h[y * size + x] = v;
        if (v < min) min = v;
        if (v > max) max = v;
      }
    }
    const inv = 1 / (max - min || 1);
    for (let i = 0; i < h.length; i++) h[i] = (h[i] - min) * inv;
    return h;
  }

  function initThreeWorld() {
    if (!USE_THREE_WORLD) return;
    if (!window.THREE) return;

    const renderer = new THREE.WebGLRenderer({
      canvas: threeCanvas,
      antialias: !IS_MOBILE,
      alpha: false,
      powerPreference: IS_MOBILE ? "low-power" : "high-performance",
    });
    // Mobile fill-rate is precious; also avoids huge drawing buffers.
    renderer.setPixelRatio(Math.min(IS_MOBILE ? 1.5 : 2, window.devicePixelRatio || 1));
    renderer.setSize(threeCanvas.clientWidth || 640, threeCanvas.clientHeight || 480, false);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, 4 / 3, 0.1, 200000);
    camera.position.set(0, 50, 50);

    const ambient = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(200, 400, 200);
    scene.add(dir);

    // Terrain
    // NOTE: Large grids require 32-bit element indices (WebGL2 or OES_element_index_uint).
    // Many mobile browsers still run WebGL1 without that extension; in that case the terrain
    // would fail to render. So we pick the largest safe size per device.
    const hasUint32Elements =
      renderer.capabilities.isWebGL2 || renderer.extensions.has("OES_element_index_uint");
    let gridSize = 1025; // higher-res (2^n + 1) for desktop
    if (IS_MOBILE) gridSize = 257; // good detail, much lighter
    if ((gridSize * gridSize) > 65535 && !hasUint32Elements) gridSize = 129; // WebGL1-safe

    // Bigger terrain so you don't "outrun" it.
    const planeSize = Math.max(120000, RUNWAY_LEN_M * 30);
    const maxHeight = 650; // reverted mountain height range
    const seaLevelN = 0.33; // lower sea level => less sand/water coverage
    // Terrain heightmap via multi-octave 2D Perlin fBm:
    // h(x,y)=Σ noise(x f_i, y f_i) a_i with increasing f_i and decreasing a_i.
    const terrainH = fractalHeightmap(gridSize, {
      seed: TERRAIN_SEED,
      // More jagged/mountainous: more octaves + higher lacunarity + slower amplitude falloff.
      // See discussion of octaves/persistence/lacunarity in fractal noise tutorials.
      octaves: IS_MOBILE ? 8 : 10,
      lacunarity: 2.25,
      persistence: 0.62,
      baseFreq: 0.0010,
    });
    const geom = new THREE.PlaneGeometry(planeSize, planeSize, gridSize - 1, gridSize - 1);
    geom.rotateX(-Math.PI / 2);

    const pos = geom.attributes.position;
    const colors = new Float32Array(pos.count * 3);
    const heights = new Float32Array(pos.count); // final height per vertex (meters)
    const color = new THREE.Color();

    for (let i = 0; i < pos.count; i++) {
      const xIndex = i % gridSize;
      const yIndex = Math.floor(i / gridSize);
      const hN0 = terrainH[yIndex * gridSize + xIndex];
      // Add stronger contrast: push highs higher and lows lower.
      // (Keeps 0..1 range so seaLevelN still behaves predictably.)
      const CONTRAST = 2.3;
      const hN1 = clamp01((hN0 - 0.5) * CONTRAST + 0.5);
      const hN = Math.pow(hN1, 1.35);

      // Base height in meters. seaLevelN defines y=0.
      let hY = (hN - seaLevelN) * maxHeight;

      // Carve runway corridor so it's always visible and surrounded by grass.
      // Geometry is centered at terrain.position.z = -RUNWAY_REF_Y, so local z=0 is runway center.
      const x = pos.getX(i);
      const z = pos.getZ(i);
      const halfRunway = RUNWAY_LEN_M * 0.5;

      // Flatten the runway footprint slightly below y=0 so the runway plane (y=1) sits above it.
      if (Math.abs(x) <= WR && Math.abs(z) <= halfRunway) {
        hY = -1.0;
      } else {
        // Grass buffer around runway
        const grassMarginX = WR * 5;       // widen grass around runway
        const grassMarginZ = halfRunway + 300;
        if (Math.abs(x) <= grassMarginX && Math.abs(z) <= grassMarginZ) {
          hY = Math.max(hY, 1.0);
        }
      }

      pos.setY(i, hY);
      heights[i] = hY;

      // Color by *height in meters* so water/sand are strictly negative.
      // Make water/sand "deeper": only sufficiently negative heights become sand/water.
      if (hY < -60) color.setHex(0x245a9c);       // water (deep)
      else if (hY < -20) color.setHex(0xcdbb8a);  // sand (deep)
      else if (hY < 80) color.setHex(0x3f7f3f);   // grass (includes shallow negatives)
      else if (hY < 260) color.setHex(0x6b6b6b);  // rock
      else color.setHex(0xf2f2f2);                // snow
      colors[i * 3 + 0] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;
    }
    pos.needsUpdate = true;
    geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({
      vertexColors: true,
      roughness: 1.0,
      metalness: 0.0,
      flatShading: false,
    });
    const terrain = new THREE.Mesh(geom, mat);
    // Center terrain so runway is roughly centered.
    terrain.position.set(0, 0, -RUNWAY_REF_Y);
    scene.add(terrain);

    // Runway mesh (simple)
    const runwayGeom = new THREE.PlaneGeometry(WR * 2, RUNWAY_LEN_M);
    runwayGeom.rotateX(-Math.PI / 2);
    const runwayMat = new THREE.MeshStandardMaterial({
      color: 0x000000, // black runway
      roughness: 1.0,
      metalness: 0.0,
      polygonOffset: true,
      polygonOffsetFactor: -2,
      polygonOffsetUnits: -2,
    });
    const runway = new THREE.Mesh(runwayGeom, runwayMat);
    // Place slightly above terrain (terrain is around y=0) to avoid z-fighting.
    runway.position.set(0, 1.0, -RUNWAY_REF_Y);
    scene.add(runway);

    function resize() {
      const w = threeCanvas.clientWidth || 640;
      const h = threeCanvas.clientHeight || 480;
      renderer.setSize(w, h, false);
      // Camera aspect is set per-frame in renderThreeWorld() to match the top window viewport.
    }
    window.addEventListener("resize", () => resize());
    resize();

    three = {
      renderer,
      scene,
      camera,
      terrainInfo: {
        gridSize,
        planeSize,
        heights,
      }
    };
  }

  function sampleTerrainHeightM(px, py) {
    if (!three || !three.terrainInfo) return 0;
    const { gridSize, planeSize, heights } = three.terrainInfo;

    // Map sim (PX, PY) to terrain local plane coords (x, z).
    // Three Z = -PY and terrain.position.z = -RUNWAY_REF_Y, so localZ = (-PY) - (-RUNWAY_REF_Y).
    const localX = px;
    const localZ = -(py - RUNWAY_REF_Y);

    // Normalize to [0..1] across plane.
    const u = clamp01(localX / planeSize + 0.5);
    const v = clamp01(localZ / planeSize + 0.5);

    const fx = u * (gridSize - 1);
    const fy = v * (gridSize - 1);
    const x0 = Math.floor(fx);
    const y0 = Math.floor(fy);
    const x1 = Math.min(gridSize - 1, x0 + 1);
    const y1 = Math.min(gridSize - 1, y0 + 1);
    const tx = fx - x0;
    const ty = fy - y0;

    const idx = (x, y) => y * gridSize + x;
    const h00 = heights[idx(x0, y0)];
    const h10 = heights[idx(x1, y0)];
    const h01 = heights[idx(x0, y1)];
    const h11 = heights[idx(x1, y1)];
    const hx0 = h00 + (h10 - h00) * tx;
    const hx1 = h01 + (h11 - h01) * tx;
    return hx0 + (hx1 - hx0) * ty;
  }

  function groundAltitudeM(px, py) {
    // Runway is treated as altitude 0 for physics/landing evaluation.
    const onRunwayFootprint =
      (Math.abs(px) <= WR) &&
      (py >= RUNWAY_START_Y) &&
      (py <= RUNWAY_END_Y);
    if (onRunwayFootprint) return 0;
    return sampleTerrainHeightM(px, py);
  }

  function updateThreeCameraFromSim() {
    if (!three) return;
    const { camera } = three;
    // Sim axes: X right, Y forward, Z up (meters)
    // Three axes: X right, Y up, Z forward/back. Map: (PX, PZ, -PY)
    camera.position.set(PX, PZ + 1.6, -PY);
    // Heading in sim increases clockwise; Three.js yaw increases CCW, so invert.
    const yawRad = -AD * C;
    const pitchRad = (-pitch * PITCH_RENDER_SCALE) * C;
    const rollRad = -roll * C;
    camera.rotation.order = "YXZ";
    camera.rotation.set(pitchRad, yawRad, rollRad);
  }

  function renderThreeWorld() {
    if (!three) return;
    updateThreeCameraFromSim();
    const { renderer, camera, scene } = three;

    // Mobile browsers can change layout height (URL bar show/hide) without a resize event.
    // Keep the WebGL drawing buffer in sync with the displayed canvas size.
    {
      // Use the overlay canvas rect as the source-of-truth for displayed size so Three.js
      // always matches the instrument canvas (prevents right-side gaps on desktop too).
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width));
      const h = Math.max(1, Math.round(rect.height));
      const s = renderer.getSize(new THREE.Vector2()); // CSS pixels
      if (Math.round(s.x) !== Math.round(w) || Math.round(s.y) !== Math.round(h)) {
        renderer.setSize(w, h, false);
      }
    }

    // Render only into the top window region (so the camera is centered in that window).
    // Use the drawing buffer size (device pixels) to avoid DPR/layout mismatches on mobile.
    const db = renderer.getDrawingBufferSize(new THREE.Vector2());
    const fullW = Math.max(1, db.x | 0);
    const fullH = Math.max(1, db.y | 0);
    const topH = Math.max(1, Math.floor(fullH * (TOP_WINDOW_H / H)));

    renderer.setScissorTest(true);
    renderer.setViewport(0, fullH - topH, fullW, topH);
    renderer.setScissor(0, fullH - topH, fullW, topH);

    camera.aspect = fullW / topH;
    camera.updateProjectionMatrix();

    renderer.render(scene, camera);
  }

  // Canvas backing-store resize (resolution independent rendering)
  let _scaleX = 1, _scaleY = 1, _pxScale = 1;
  function resizeCanvasToWindowIfNeeded() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(1, rect.width);
    const cssH = Math.max(1, rect.height);
    const newW = Math.max(1, Math.round(cssW * dpr));
    const newH = Math.max(1, Math.round(cssH * dpr));
    if (canvas.width === newW && canvas.height === newH) return;
    canvas.width = newW;
    canvas.height = newH;
    _scaleX = newW / W;
    _scaleY = newH / H;
    _pxScale = (_scaleX + _scaleY) * 0.5;
    ctx.setTransform(_scaleX, 0, 0, _scaleY, 0, 0);
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
  }
  window.addEventListener("resize", () => resizeCanvasToWindowIfNeeded());

  // Controls canvas backing-store resize (mobile controls)
  let _cScaleX = 1, _cScaleY = 1, _cPxScale = 1;
  function resizeControlsCanvasToWindowIfNeeded() {
    if (!controlsCanvas || !cctx) return;
    const dpr = window.devicePixelRatio || 1;
    const rect = controlsCanvas.getBoundingClientRect();
    const cssW = Math.max(1, rect.width);
    const cssH = Math.max(1, rect.height);
    const newW = Math.max(1, Math.round(cssW * dpr));
    const newH = Math.max(1, Math.round(cssH * dpr));
    if (controlsCanvas.width === newW && controlsCanvas.height === newH) return;
    controlsCanvas.width = newW;
    controlsCanvas.height = newH;
    _cScaleX = newW / W;
    _cScaleY = newH / H;
    _cPxScale = (_cScaleX + _cScaleY) * 0.5;
    cctx.setTransform(_cScaleX, 0, 0, _cScaleY, 0, 0);
    cctx.lineCap = "butt";
    cctx.lineJoin = "miter";
  }
  window.addEventListener("resize", () => resizeControlsCanvasToWindowIfNeeded());

  function clearScreen() {
    resizeCanvasToWindowIfNeeded();
    // Transparent clear so Three.js can show through.
    ctx.setTransform(_scaleX, 0, 0, _scaleY, 0, 0);
    ctx.clearRect(0, 0, W, H);
  }

  function drawInstrumentPanelBackground() {
    // Opaque instrument panel (bottom area), so instruments remain readable.
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, TOP_WINDOW_H, W, H - TOP_WINDOW_H);
    // On mobile the boundary line tends to feel "too low" once the 3D window is taller;
    // keep the UI cleaner by omitting it.
    if (!IS_MOBILE) {
      ctx.strokeStyle = "#fff";
      line(0, TOP_WINDOW_H, W, TOP_WINDOW_H);
    }
    ctx.restore();
  }
  function _snapToDevicePixelCenterX(x) {
    // Convert to device pixels, snap to pixel center, convert back to logical coords.
    return (Math.round(x * _scaleX) + 0.5) / _scaleX;
  }
  function _snapToDevicePixelCenterY(y) {
    return (Math.round(y * _scaleY) + 0.5) / _scaleY;
  }
  function line(x1, y1, x2, y2) {
    // Keep strokes 1 device pixel wide regardless of canvas scaling.
    ctx.lineWidth = 1 / _pxScale;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
  function lineSnapped(x1, y1, x2, y2) {
    // Snap endpoints to device-pixel centers to avoid shimmering/flicker with anti-aliasing.
    x1 = _snapToDevicePixelCenterX(x1);
    x2 = _snapToDevicePixelCenterX(x2);
    y1 = _snapToDevicePixelCenterY(y1);
    y2 = _snapToDevicePixelCenterY(y2);
    line(x1, y1, x2, y2);
  }
  function dotSnapped(x, y) {
    // Draw a single device pixel at (x,y) in logical coordinates.
    const px = Math.round(x * _scaleX);
    const py = Math.round(y * _scaleY);
    ctx.fillRect(px / _scaleX, py / _scaleY, 1 / _scaleX, 1 / _scaleY);
  }
  function dotSoft(x, y) {
    // Draw ~1 device-pixel dot but do NOT snap to pixel centers (reduces moiré patterns).
    const w = 1 / _scaleX;
    const h = 1 / _scaleY;
    ctx.fillRect(x - w * 0.5, y - h * 0.5, w, h);
  }
  function dotSoftPx(x, y, pxSize) {
    // Draw a pxSize x pxSize dot in *device pixels* (converted to logical coords),
    // without snapping to pixel centers.
    const w = pxSize / _scaleX;
    const h = pxSize / _scaleY;
    ctx.fillRect(x - w * 0.5, y - h * 0.5, w, h);
  }
  function circle(cx, cy, r) {
    ctx.lineWidth = 1 / _pxScale;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
  }
  function dialBezel(cx, cy, r) {
    // Two concentric circles + a square bezel with corner screws (minimalist).
    const outerR = r + 2;
    circle(cx, cy, r);
    circle(cx, cy, outerR);

    // Square frame a few pixels larger than the outer circle diameter.
    const pad = 1;
    const half = outerR + pad;
    ctx.save();
    ctx.lineWidth = 1 / _pxScale;
    ctx.strokeRect(cx - half, cy - half, half * 2, half * 2);

    // Corner screws: 5px diameter circles with a small "slot" line.
    const screwR = 1.5;
    const slotLen = 3;
    const screw_pad = outerR - 2;
    const corners = [
      [cx - screw_pad, cy - screw_pad],
      [cx + screw_pad, cy - screw_pad],
      [cx + screw_pad, cy + screw_pad],
      [cx - screw_pad, cy + screw_pad],
    ];
    for (const [sx, sy] of corners) {
      ctx.beginPath();
      ctx.arc(sx, sy, screwR, 0, 2 * PI);
      ctx.stroke();
      // Slot line (slightly angled)
      const a = 45 * C;
      const dx = Math.cos(a) * slotLen * 0.5;
      const dy = Math.sin(a) * slotLen * 0.5;
      line(sx - dx, sy - dy, sx + dx, sy + dy);
    }
    ctx.restore();
  }
  function needle(cx, cy, len, aRad) {
    // Narrow lozenge (diamond) pointer instead of a single line.
    const ux = Math.sin(aRad);
    const uy = -Math.cos(aRad);
    const px = Math.cos(aRad);
    const py = Math.sin(aRad);

    const tip = len;
    const tail = len * 0.18;
    const mid = len * 0.22;
    const halfW = Math.max(1.0 / _pxScale, len * 0.06);

    const xTip = cx + ux * tip;
    const yTip = cy + uy * tip;
    const xTail = cx - ux * tail;
    const yTail = cy - uy * tail;

    const xL = cx + ux * mid + px * halfW;
    const yL = cy + uy * mid + py * halfW;
    const xR = cx + ux * mid - px * halfW;
    const yR = cy + uy * mid - py * halfW;

    ctx.save();
    ctx.lineWidth = 1 / _pxScale;
    ctx.beginPath();
    ctx.moveTo(xTip, yTip);
    ctx.lineTo(xL, yL);
    ctx.lineTo(xTail, yTail);
    ctx.lineTo(xR, yR);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function textCentered(cx, y, s) {
    const w = ctx.measureText(s).width;
    ctx.fillText(s, cx - w / 2, y);
  }

  // Liang–Barsky line clipping
  function clipLineToRect(x1, y1, x2, y2, rx, ry, rw, rh) {
    let t0 = 0, t1 = 1;
    const dx = x2 - x1, dy = y2 - y1;
    function clip(p, q) {
      if (p === 0) return q >= 0;
      const r = q / p;
      if (p < 0) { if (r > t1) return false; if (r > t0) t0 = r; }
      else       { if (r < t0) return false; if (r < t1) t1 = r; }
      return true;
    }
    if (
      clip(-dx, x1 - rx) &&
      clip( dx, (rx + rw) - x1) &&
      clip(-dy, y1 - ry) &&
      clip( dy, (ry + rh) - y1)
    ) {
      const nx1 = x1 + t0 * dx, ny1 = y1 + t0 * dy;
      const nx2 = x1 + t1 * dx, ny2 = y1 + t1 * dy;
      return [nx1, ny1, nx2, ny2];
    }
    return null;
  }

  // Polygon clipping (Sutherland–Hodgman) against axis-aligned rectangle
  function clipPolygonRect(poly, xmin, xmax, ymin, ymax) {
    function clipEdge(points, insideFn, intersectFn) {
      const out = [];
      if (!points.length) return out;
      let S = points[points.length - 1];
      for (const E of points) {
        const Ein = insideFn(E);
        const Sin = insideFn(S);
        if (Ein) {
          if (!Sin) out.push(intersectFn(S, E));
          out.push(E);
        } else if (Sin) {
          out.push(intersectFn(S, E));
        }
        S = E;
      }
      return out;
    }

    function intersectX(p1, p2, x) {
      const [x1,y1] = p1, [x2,y2] = p2;
      const dx = x2 - x1;
      if (dx === 0) return [x, y1];
      const t = (x - x1) / dx;
      return [x, y1 + t * (y2 - y1)];
    }
    function intersectY(p1, p2, y) {
      const [x1,y1] = p1, [x2,y2] = p2;
      const dy = y2 - y1;
      if (dy === 0) return [x1, y];
      const t = (y - y1) / dy;
      return [x1 + t * (x2 - x1), y];
    }

    let out = poly.slice();
    out = clipEdge(out, p => p[0] >= xmin, (s,e) => intersectX(s,e,xmin));
    out = clipEdge(out, p => p[0] <= xmax, (s,e) => intersectX(s,e,xmax));
    out = clipEdge(out, p => p[1] >= ymin, (s,e) => intersectY(s,e,ymin));
    out = clipEdge(out, p => p[1] <= ymax, (s,e) => intersectY(s,e,ymax));
    return out;
  }

  function drawPolygon(poly) {
    if (!poly || poly.length < 2) return;
    for (let i = 0; i < poly.length; i++) {
      const a = poly[i];
      const b = poly[(i + 1) % poly.length];
      line(a[0], a[1], b[0], b[1]);
    }
  }

  // --- Minimal 3D camera (world meters) for the top window ---
  function v3(x, y, z) { return { x, y, z }; }
  function v3sub(a, b) { return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }; }
  function v3add(a, b) { return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }; }
  function v3mul(a, s) { return { x: a.x * s, y: a.y * s, z: a.z * s }; }
  function v3dot(a, b) { return a.x * b.x + a.y * b.y + a.z * b.z; }

  function computeCameraBasis(yawDeg, pitchNoseUpDeg, rollDeg) {
    // World axes: +X right, +Y forward, +Z up. Camera axes: +x right, +y down, +z forward.
    const psi = yawDeg * C;
    const th = pitchNoseUpDeg * C;
    const ph = rollDeg * C;

    // Start at level flight heading +Y.
    let f = v3(Math.sin(psi), Math.cos(psi), 0);
    let r = v3(Math.cos(psi), -Math.sin(psi), 0);
    let u = v3(0, 0, 1);

    // Pitch about right axis (nose up positive).
    {
      const f0 = f, u0 = u;
      f = v3add(v3mul(f0, Math.cos(th)), v3mul(u0, Math.sin(th)));
      u = v3add(v3mul(u0, Math.cos(th)), v3mul(f0, -Math.sin(th)));
    }

    // Roll about forward axis.
    const r2 = v3add(v3mul(r, Math.cos(ph)), v3mul(u, Math.sin(ph)));
    const u2 = v3add(v3mul(u, Math.cos(ph)), v3mul(r, -Math.sin(ph)));
    r = r2; u = u2;

    return { camRight: r, camDown: v3mul(u, -1), camFwd: f };
  }

  function worldToCamera(pWorld, camPos, basis) {
    const rel = v3sub(pWorld, camPos);
    return v3(
      v3dot(rel, basis.camRight),
      v3dot(rel, basis.camDown),
      v3dot(rel, basis.camFwd)
    );
  }

  function clipSegmentToNearPlane(p1, p2, nearZ) {
    // Keep z >= nearZ
    const z1 = p1.z, z2 = p2.z;
    const in1 = z1 >= nearZ, in2 = z2 >= nearZ;
    if (in1 && in2) return [p1, p2];
    if (!in1 && !in2) return null;
    const t = (nearZ - z1) / (z2 - z1);
    const pi = v3add(p1, v3mul(v3sub(p2, p1), t));
    if (!in1) return [pi, p2];
    return [p1, pi];
  }

  function clipPolygonToNearPlane(polyCam, nearZ) {
    // Sutherland–Hodgman in camera space, keep z >= nearZ
    const out = [];
    if (!polyCam || polyCam.length < 3) return out;
    let S = polyCam[polyCam.length - 1];
    const Sin = S.z >= nearZ;
    let SinFlag = Sin;
    for (const E of polyCam) {
      const EinFlag = E.z >= nearZ;
      if (EinFlag) {
        if (!SinFlag) {
          const t = (nearZ - S.z) / (E.z - S.z);
          out.push(v3add(S, v3mul(v3sub(E, S), t)));
        }
        out.push(E);
      } else if (SinFlag) {
        const t = (nearZ - S.z) / (E.z - S.z);
        out.push(v3add(S, v3mul(v3sub(E, S), t)));
      }
      S = E;
      SinFlag = EinFlag;
    }
    return out;
  }

  function projectCamToScreen(pCam, intr) {
    // Accept points exactly on the near plane (z == nearZ). Polygons/segments are
    // clipped to nearZ, and rejecting equality can cause geometry to disappear
    // at low altitude/pitch when many points land exactly on the plane.
    if (pCam.z < intr.nearZ) return null;
    const x = intr.cx + intr.f * (pCam.x / pCam.z);
    const y = intr.cy + intr.f * (pCam.y / pCam.z);
    if (!isFinite(x) || !isFinite(y)) return null;
    return [x, y];
  }

  function lineRectIntersections(A, B, Cc, xmin, xmax, ymin, ymax) {
    // Line: A*x + B*y + Cc = 0. Return up to 2 unique points on the rectangle boundary.
    const pts = [];
    const eps = 1e-9;
    function addPt(x, y) {
      if (!isFinite(x) || !isFinite(y)) return;
      if (x < xmin - 1e-6 || x > xmax + 1e-6 || y < ymin - 1e-6 || y > ymax + 1e-6) return;
      for (const p of pts) {
        if (Math.abs(p[0] - x) < 0.25 && Math.abs(p[1] - y) < 0.25) return;
      }
      pts.push([x, y]);
    }

    // x = xmin/xmax -> solve for y
    if (Math.abs(B) > eps) {
      addPt(xmin, -(A * xmin + Cc) / B);
      addPt(xmax, -(A * xmax + Cc) / B);
    }
    // y = ymin/ymax -> solve for x
    if (Math.abs(A) > eps) {
      addPt(-(B * ymin + Cc) / A, ymin);
      addPt(-(B * ymax + Cc) / A, ymax);
    }
    if (pts.length <= 2) return pts;
    // If we got more due to corner hits, keep the two farthest apart
    let best = [pts[0], pts[1]];
    let bestD = -1;
    for (let i = 0; i < pts.length; i++) {
      for (let j = i + 1; j < pts.length; j++) {
        const dx = pts[i][0] - pts[j][0];
        const dy = pts[i][1] - pts[j][1];
        const d = dx * dx + dy * dy;
        if (d > bestD) { bestD = d; best = [pts[i], pts[j]]; }
      }
    }
    return best;
  }

  // --- Game state ---
  let running = false;
  let ended = false;
  let started = false;
  let endMessage = [];

  // Landing-game coordinates (metric)
  let PX = 0, PY = 0, PZ = 0; // meters; PZ is altitude above runway plane
  let VX = 0, VY = 0, VZ = 0; // m/s (derived from flight model)
  let GX = 0, GY = 0, GZ = 0; // m/s with wind
  let AD = 0;                 // heading degrees (0..360)

  // Wind (metric, m/s)
  let WX = 0, WY = 0;

  // --- C++ flight-model state (ported) ---
  // Control surfaces (reduced indices, -15..+15)
  let aileron_pos = 0;
  let elevator_pos = 0;
  let rudder_pos = 0;
  let rudder_cmd = 0; // [-1..1] ramped command for smoother digital-key rudder

  // --- Mobile touch controls (normalized inputs) ---
  const mobileCtl = {
    // stick: right side, self-centering
    stickId: null,
    stickX: 0, // [-1..1]
    stickY: 0, // [-1..1] (screen coords; up is negative)
    // throttle: left side, non-centering
    throttleId: null,
    throttleN: 0, // [0..1]
    // rudder: left side, self-centering horizontal slider
    rudderId: null,
    rudderN: 0, // [-1..1]
    // tap buttons
    tapId: null,
    tapKind: null,
    tapX0: 0,
    tapY0: 0,
  };

  function _lerp(a, b, t) { return a + (b - a) * t; }
  function _invLerp(a, b, v) { return (v - a) / (b - a); }
  function mobileLayout() {
    // Logical coordinates for the *controls canvas* (W x H), independent from instruments.
    const margin = 10;
    const yTop = margin;
    const yBot = H - margin;

    const stickR = 34;
    const stickCx = W - margin - stickR;
    const stickCy = Math.floor((yTop + yBot) * 0.5) - 6;

    const thW = 26;
    const thH = Math.max(78, (yBot - yTop) - 62);
    const thX = margin + 10;
    const thY = yTop + 10;

    const rudH = 14;
    // Keep rudder fully visible (knob extends beyond the track a bit).
    const rudY = Math.min(yBot - rudH - 14, thY + thH + 14);
    const rudX0 = margin;
    const rudX1 = Math.min(W * 0.55, stickCx - stickR - 18);

    const btnW = 54;
    const btnH = 24;
    // Buttons: center horizontally (requested), and keep well away from the stick on the right.
    const btnX = clamp(Math.floor(W * 0.5 - btnW * 0.5), margin, W - margin - btnW);
    const brakeY = clamp(yTop + 22, yTop, yBot - btnH);
    const muteY  = clamp(brakeY + btnH + 24, yTop, yBot - btnH);

    return {
      stick: { cx: stickCx, cy: stickCy, r: stickR },
      throttle: { x: thX, y: thY, w: thW, h: thH },
      rudder: { x0: rudX0, x1: rudX1, y: rudY, h: rudH },
      brakeBtn: { x: btnX, y: brakeY, w: btnW, h: btnH },
      muteBtn: { x: btnX, y: muteY, w: btnW, h: btnH },
      yTop, yBot,
    };
  }

  function _evtToLogical(e, el) {
    const rect = el.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / Math.max(1, rect.width)) * W;
    const y = ((e.clientY - rect.top) / Math.max(1, rect.height)) * H;
    return { x, y };
  }
  function _inRect(x, y, r) {
    return x >= r.x && x <= (r.x + r.w) && y >= r.y && y <= (r.y + r.h);
  }
  function _dist2(ax, ay, bx, by) {
    const dx = ax - bx, dy = ay - by;
    return dx * dx + dy * dy;
  }
  let brake = true;

  // Engine / power
  let ignition_on = true;
  let engine_on = true;
  let throttle_pos = 0; // scaled from TC for C++ formulas
  let rpm = 0;

  // Attitude (degrees)
  let roll = 0;
  let pitch = 0;
  let yaw = 0; // degrees, mapped to AD

  // Speeds tuned like C++ (mostly mph and feet-per-loop)
  let h_speed_mph = 0;       // horizontal speed (mph)
  let v_speed_ft = 0;        // vertical displacement per loop (feet/loop)
  let delta_z_ft = 0;        // forward displacement per loop (feet/loop)
  let efAOF_rad = 0;         // effective angle of flight (radians)
  let stall = false;
  let airborne = true;

  // Rotational deltas (degrees per loop; C++ labels deg/ms but applies as deg/loop)
  const deltaVect = { dPitch: 0, dYaw: 0, dRoll: 0 };

  // User-facing throttle knob (kept for RPM dial behavior)
  let TC = 5; // 0.2..8.8

  // --- Longitudinal stability tuning (GA-like) ---
  // Map power setting to a hands-off trim speed, then apply restoring pitch moments
  // when the aircraft is faster/slower than that trim speed.
  function trimSpeedMphFromThrottle() {
    // Throttle command normalized.
    const tN = clamp01((TC - 0.2) / (8.8 - 0.2));
    // Keep above stall and below the 400 km/h cap used elsewhere.
    const TRIM_MIN_KMH = 120;
    const TRIM_MAX_KMH = 380;
    return _lerp(TRIM_MIN_KMH, TRIM_MAX_KMH, tN) * KMH_TO_MPH;
  }

  const RT = 3, TP = 5, WR = 50; // landing thresholds: roll, pitch, runway half-width (meters)

  // Runway model used by the renderer/instruments (world meters).
  // The 3D runway drawing uses a strip starting at Y=0 (touchdown threshold)
  // extending forward (+Y). Instruments should reference the same runway geometry.
  const RUNWAY_START_Y = 0;
  const RUNWAY_LEN_M = 3000;
  const RUNWAY_END_Y = RUNWAY_START_Y + RUNWAY_LEN_M;
  const RUNWAY_REF_Y = RUNWAY_START_Y + RUNWAY_LEN_M * 0.5; // instrument reference point on runway

  const keysDown = new Set();
  let bWasDown = false;

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    // Audio mute toggle (no UI; hotkey only).
    if (k === "m" && !e.repeat) {
      ensureAudioStarted();
      setMuted(!audioMuted);
      return;
    }

    // End screen choices: ignore repeats so holding a key won't restart instantly.
    // R = restart (yes), N = stop (no).
    if (ended && (k === "r" || k === "n")) {
      if (e.repeat) return;
      if (k === "r") {
        // Resume audio inside this user gesture, then restart.
        ensureAudioStarted();
        document.getElementById("startBtn").click();
      }
      else if (k === "n") {
        running = false;
        ended = true;
        endMessage = ["Encerrado.", "Recarregue a página para jogar novamente."];
        stopEngineAudio();
      }
      return;
    }

    keysDown.add(k);
  });
  window.addEventListener("keyup", (e) => keysDown.delete(e.key.toLowerCase()));

  // --- Mobile pointer controls (on the controls canvas) ---
  if (IS_MOBILE && controlsCanvas) {
    // Prevent touch scrolling/zooming while interacting with the controls.
    controlsCanvas.style.touchAction = "none";
  }

  function _toggleBrake() {
    brake = !brake;
  }
  function _toggleMute() {
    ensureAudioStarted();
    setMuted(!audioMuted);
  }

  function _updateStickFromPoint(x, y) {
    const { stick } = mobileLayout();
    const dx = x - stick.cx;
    const dy = y - stick.cy;
    const r = stick.r;
    let nx = dx / r;
    let ny = dy / r;
    const mag = Math.hypot(nx, ny);
    if (mag > 1) { nx /= mag; ny /= mag; }
    // deadzone
    const dz = 0.12;
    if (Math.hypot(nx, ny) < dz) { nx = 0; ny = 0; }
    mobileCtl.stickX = clamp(nx, -1, 1);
    mobileCtl.stickY = clamp(ny, -1, 1);
  }
  function _updateThrottleFromPoint(x, y) {
    const { throttle } = mobileLayout();
    const t = clamp01(1 - ((y - throttle.y) / Math.max(1, throttle.h)));
    mobileCtl.throttleN = t;
  }
  function _updateRudderFromPoint(x, y) {
    const { rudder } = mobileLayout();
    const cx = (rudder.x0 + rudder.x1) * 0.5;
    const half = Math.max(1, (rudder.x1 - rudder.x0) * 0.5);
    // Map drag-right => right rudder (match expected left/right behavior).
    mobileCtl.rudderN = clamp((cx - x) / half, -1, 1);
  }

  if (controlsCanvas) controlsCanvas.addEventListener("pointerdown", (e) => {
    if (!IS_MOBILE) return;
    if (ended) return;
    const { x, y } = _evtToLogical(e, controlsCanvas);
    const L = mobileLayout();

    // Assign pointer to the first matching control.
    if (mobileCtl.stickId == null && _dist2(x, y, L.stick.cx, L.stick.cy) <= (L.stick.r * 1.35) ** 2) {
      mobileCtl.stickId = e.pointerId;
      controlsCanvas.setPointerCapture(e.pointerId);
      _updateStickFromPoint(x, y);
      return;
    }
    if (mobileCtl.throttleId == null && _inRect(x, y, L.throttle)) {
      mobileCtl.throttleId = e.pointerId;
      controlsCanvas.setPointerCapture(e.pointerId);
      _updateThrottleFromPoint(x, y);
      return;
    }
    if (mobileCtl.rudderId == null && (x >= L.rudder.x0 && x <= L.rudder.x1 && y >= L.rudder.y && y <= (L.rudder.y + L.rudder.h))) {
      mobileCtl.rudderId = e.pointerId;
      controlsCanvas.setPointerCapture(e.pointerId);
      _updateRudderFromPoint(x, y);
      return;
    }

    // Buttons (tap).
    if (_inRect(x, y, L.brakeBtn)) {
      mobileCtl.tapId = e.pointerId;
      mobileCtl.tapKind = "brake";
      mobileCtl.tapX0 = x;
      mobileCtl.tapY0 = y;
      controlsCanvas.setPointerCapture(e.pointerId);
      return;
    }
    if (_inRect(x, y, L.muteBtn)) {
      mobileCtl.tapId = e.pointerId;
      mobileCtl.tapKind = "mute";
      mobileCtl.tapX0 = x;
      mobileCtl.tapY0 = y;
      controlsCanvas.setPointerCapture(e.pointerId);
      return;
    }
  });

  if (controlsCanvas) controlsCanvas.addEventListener("pointermove", (e) => {
    if (!IS_MOBILE) return;
    if (ended) return;
    const { x, y } = _evtToLogical(e, controlsCanvas);
    if (mobileCtl.stickId === e.pointerId) { _updateStickFromPoint(x, y); return; }
    if (mobileCtl.throttleId === e.pointerId) { _updateThrottleFromPoint(x, y); return; }
    if (mobileCtl.rudderId === e.pointerId) { _updateRudderFromPoint(x, y); return; }
  });

  function _releasePointer(e) {
    if (!IS_MOBILE) return;
    if (!controlsCanvas) return;
    const { x, y } = _evtToLogical(e, controlsCanvas);
    const L = mobileLayout();

    // Tap buttons
    if (mobileCtl.tapId === e.pointerId) {
      const moved = Math.hypot(x - mobileCtl.tapX0, y - mobileCtl.tapY0);
      if (moved < 6) {
        if (mobileCtl.tapKind === "brake" && _inRect(x, y, L.brakeBtn)) _toggleBrake();
        if (mobileCtl.tapKind === "mute" && _inRect(x, y, L.muteBtn)) _toggleMute();
      }
      mobileCtl.tapId = null;
      mobileCtl.tapKind = null;
    }

    if (mobileCtl.stickId === e.pointerId) mobileCtl.stickId = null;
    if (mobileCtl.throttleId === e.pointerId) mobileCtl.throttleId = null;
    if (mobileCtl.rudderId === e.pointerId) mobileCtl.rudderId = null;
  }
  if (controlsCanvas) {
    controlsCanvas.addEventListener("pointerup", _releasePointer);
    controlsCanvas.addEventListener("pointercancel", _releasePointer);
  }

  function setDemoScreenState() {
    running = false;
    ended = false;
    endMessage = [];
    // Pre-start demo state: place aircraft on approach so the 3D outside view is meaningful
    // even before clicking "Iniciar voo". (Sim remains paused until start.)
    PX = 0;
    PY = -10000;
    PZ = 750;
    VX = 0; VY = 0; VZ = 0;
    GX = 0; GY = 0; GZ = 0;
    AD = 0;
    WX = 0; WY = 0;

    aileron_pos = 0;
    elevator_pos = 0;
    rudder_pos = 0;
    rudder_cmd = 0;
    brake = true;
    ignition_on = true;
    engine_on = true;
    throttle_pos = clamp(((2000 - RPM_IDLE) / ((RPM_MAX - RPM_IDLE) / 75)), 0, 75);
    rpm = 2000;
    roll = 0;
    pitch = 0;
    yaw = 0;
    h_speed_mph = 200 * KMH_TO_MPH;
    v_speed_ft = 0;
    delta_z_ft = 0;
    efAOF_rad = 0;
    stall = false;
    airborne = true;
    deltaVect.dPitch = deltaVect.dYaw = deltaVect.dRoll = 0;
    TC = 5;

    bWasDown = false;
    keysDown.clear();

    // Keep mobile throttle slider consistent with the current engine command,
    // so starting the sim won't instantly jump the throttle.
    mobileCtl.throttleN = clamp01(_invLerp(0.2, 8.8, TC));
  }

  function resetGame(windSpeed, windDir) {
    ended = false;
    endMessage = [];
    keysDown.clear();

    // Start position (metric)
    PX = 0;
    PY = -10000;
    // Add ~10% randomness to initial altitude.
    PZ = 750 * randMul(0.10);

    // Start attitude
    roll = 0;
    pitch = 0;
    // Add ~10% randomness to initial bearing (±36° around north).
    yaw = randSigned() * 36;
    AD = wrap360(yaw);

    // Start throttle / engine
    // Initialize throttle so the starting RPM is ~2000 and stable (nominal ~= rpm).
    {
      const THROTTLE_POS_MAX = 75;
      const RPM_PER_THROTTLE = (RPM_MAX - RPM_IDLE) / THROTTLE_POS_MAX;
      const RPM_START = 2000;
      throttle_pos = clamp((RPM_START - RPM_IDLE) / RPM_PER_THROTTLE, 0, THROTTLE_POS_MAX);
      TC = clamp(throttle_pos / 8.5, 0.2, 8.8);
    }
    ignition_on = true;
    engine_on = true;

    // Start speed (+/- 10% randomness).
    const START_SPEED_KMH = 200 * randMul(0.10);
    h_speed_mph = START_SPEED_KMH * KMH_TO_MPH;

    // Start rpm
    rpm = 2000;

    // Sync mobile throttle slider to the current TC so touch controls match RPM at start.
    mobileCtl.throttleN = clamp01(_invLerp(0.2, 8.8, TC));

    // Wind scaling from original BASIC: windSpeed/3
    const X0 = windSpeed / 3;
    const X1 = windDir;
    WY = X0 * Math.cos(X1 * C);
    WX = -X0 * Math.sin(X1 * C);

    // Controls reset
    aileron_pos = 0;
    elevator_pos = 0;
    rudder_pos = 0;
    rudder_cmd = 0;
    brake = false;
    stall = false;
    airborne = true;
    deltaVect.dPitch = deltaVect.dYaw = deltaVect.dRoll = 0;
    v_speed_ft = 0;
    delta_z_ft = 0;
    efAOF_rad = 0;

    running = true;
  }

  function rads(deg) {
    if (deg < 0) deg += 360;
    return deg * C;
  }
  function degs(rad) {
    return rad / C;
  }

  function updateControls(dt) {
    // --- Mobile self-centering decay (runs even if the user isn't touching) ---
    if (IS_MOBILE) {
      // Stick returns to center slowly when released.
      if (mobileCtl.stickId == null) {
        const k = 1 - Math.exp(-3.2 * dt);
        mobileCtl.stickX += (0 - mobileCtl.stickX) * k;
        mobileCtl.stickY += (0 - mobileCtl.stickY) * k;
      }
      // Rudder slider returns to center when released.
      if (mobileCtl.rudderId == null) {
        const k = 1 - Math.exp(-5.0 * dt);
        mobileCtl.rudderN += (0 - mobileCtl.rudderN) * k;
      }
      // Throttle is non-centering; keep last value.
      // Keep TC in sync with slider (chosen mapping: slider -> TC).
      TC = _lerp(0.2, 8.8, clamp01(mobileCtl.throttleN));
    }

    // Throttle change is time-based. Preserve ~0.2 per tick @60Hz feel.
    // In mobile mode, Q/E nudges on top of the slider and we reflect that back into throttleN.
    const TC_RATE = 12.0;
    if (keysDown.has("q")) TC += TC_RATE * dt;
    if (keysDown.has("e")) TC -= TC_RATE * dt;
    TC = clamp(TC, 0.2, 8.8);
    if (IS_MOBILE) {
      mobileCtl.throttleN = clamp01(_invLerp(0.2, 8.8, TC));
    }

    // Toggle brakes (edge-triggered)
    const bDown = keysDown.has("b");
    if (bDown && !bWasDown) brake = !brake;
    bWasDown = bDown;

    // Roll: A/D
    let rollIn = 0;
    if (keysDown.has("a")) rollIn -= 1;
    if (keysDown.has("d")) rollIn += 1;

    // Pitch: W nose up, S nose down (inverted compared to the prior mapping).
    let pitchIn = 0;
    if (keysDown.has("w")) pitchIn += 1;
    if (keysDown.has("s")) pitchIn -= 1;

    // Rudder: Z/C
    let rudderIn = 0;
    if (keysDown.has("z")) rudderIn += 1;
    if (keysDown.has("c")) rudderIn -= 1;

    // Mobile blending: add touch inputs to keyboard inputs.
    if (IS_MOBILE) {
      rollIn += mobileCtl.stickX;
      // stickY is positive downward; invert so pushing up means nose up.
      pitchIn += -mobileCtl.stickY;
      rudderIn += mobileCtl.rudderN;
    }

    // Control surfaces: self-centering with a smooth first-order response.
    // The straight port that *integrates* surface position can "wind up" and
    // keep rolling/looping even after keys are released. This makes the sim
    // far more controllable while still using the C++ dynamics core.
    const AIL_TARGET = rollIn * 15;
    const ELE_TARGET = pitchIn * 15;
    // Rudder: use a ramped command so taps produce tiny changes and holding a key ramps
    // toward full deflection. This makes drift/ILS fine-tuning much easier.
    const RUD_CMD_RATE = 2.0;     // 1/s ramp-up speed
    const RUD_CENTER_RATE = 5.0;  // 1/s return-to-center when released
    if (rudderIn !== 0) {
      rudder_cmd = clamp(rudder_cmd + rudderIn * RUD_CMD_RATE * dt, -1, 1);
    } else {
      // Exponential decay toward 0
      const k = 1 - Math.exp(-RUD_CENTER_RATE * dt);
      rudder_cmd += (0 - rudder_cmd) * k;
    }

    const RUD_TARGET = rudder_cmd * 10; // degrees (max deflection)
    const SURF_RESP = 5.0;      // aileron/elevator response
    const RUD_SURF_RESP = 2.0;  // slower rudder response for smoother control
    const alpha = 1 - Math.exp(-SURF_RESP * dt);
    const alphaR = 1 - Math.exp(-RUD_SURF_RESP * dt);
    aileron_pos = clamp(aileron_pos + (AIL_TARGET - aileron_pos) * alpha, -15, 15);
    elevator_pos = clamp(elevator_pos + (ELE_TARGET - elevator_pos) * alpha, -15, 15);

    rudder_pos = clamp(rudder_pos + (RUD_TARGET - rudder_pos) * alphaR, -15, 15);

    // Throttle position for C++ formulas (0..~75)
    throttle_pos = clamp(TC * 8.5, 0, 75);
  }

  function calcPowerDyn(loopTimeMs) {
    if (ignition_on) {
      if (!engine_on) engine_on = true;
      // Map throttle_pos (0..75) to RPM range (idle..RPM_MAX) so throttle isn't overly strong.
      const THROTTLE_POS_MAX = 75;
      const RPM_PER_THROTTLE = (RPM_MAX - RPM_IDLE) / THROTTLE_POS_MAX;
      const nominal = RPM_IDLE + (throttle_pos * RPM_PER_THROTTLE);
      if (rpm < nominal) rpm += loopTimeMs * 0.5;
      if (rpm > nominal) rpm -= loopTimeMs * 0.5;
    } else {
      if (engine_on) engine_on = false;
      if (rpm) rpm -= (loopTimeMs / 2);
    }
    if (rpm < 0) rpm = 0;
    // Minimum running/idle RPM while ignition is on.
    if (ignition_on && rpm > 0 && rpm < RPM_IDLE) rpm = RPM_IDLE;
    if (rpm > RPM_MAX) rpm = RPM_MAX;
  }

  function calcFlightDyn(loopTimeMs) {
    // Port of AirCraft::CalcFlightDyn with the same tuning assumptions.
    const STALL_SPEED_MPH = 80 * KMH_TO_MPH;   // stall threshold at 80 km/h
    // Tune: rpm hard-caps at 3000, so set this so max rpm yields ~400 km/h (~248.5 mph).
    const RPM_TO_MPH = RPM_MAX / (400 * KMH_TO_MPH);

    let iSpeed = rpm / RPM_TO_MPH;
    iSpeed += (pitch * 1.5);

    let hAccel = ((rpm * (iSpeed - h_speed_mph)) / 10000);
    hAccel /= 1000;
    hAccel *= loopTimeMs;

    // Brake acts as:
    // - Strong ground brake when on wheels
    // - Gentle airbrake when airborne (time-based so it doesn't instantly zero the airspeed)
    const BRAKE_GROUND_DECEL_MPH = 1.0;
    const AIRBRAKE_K = 0.35; // 1/s (higher = stronger). ~50% reduction in ~2.0s.

    if (brake && !airborne) {
      h_speed_mph = Math.max(0, h_speed_mph - BRAKE_GROUND_DECEL_MPH);
    } else {
      h_speed_mph += hAccel;
      if (brake && airborne) {
        const dt = loopTimeMs / 1000;
        const dragMul = Math.exp(-AIRBRAKE_K * dt);
        h_speed_mph *= dragMul;
      }
    }

    // Lift curve
    let lSpeed = (h_speed_mph / STALL_SPEED_MPH) - 1;
    if (lSpeed > 1) lSpeed = 1;
    let lVeloc = degs(Math.atan(lSpeed));
    lVeloc += 45;
    lVeloc /= 5.29;
    lVeloc *= (-(pitch * 0.157) + 1);
    lVeloc /= 1000;
    lVeloc *= loopTimeMs;

    // Gravity term (closer to real-world: ~-32.2 ft/s^2)
    const GRAV_C_FTPS = -32.0;
    const gVeloc = loopTimeMs * (GRAV_C_FTPS / 1000);
    v_speed_ft = gVeloc + lVeloc;
    if ((!airborne) && (v_speed_ft < 0)) v_speed_ft = 0;

    // Forward displacement from mph
    delta_z_ft = h_speed_mph * 5280;
    delta_z_ft /= 3600000;
    delta_z_ft *= loopTimeMs;

    // Effective angle of flight
    if (delta_z_ft) efAOF_rad = -(Math.atan(v_speed_ft / delta_z_ft));
    else efAOF_rad = -(Math.atan(v_speed_ft));

    const AOA = degs(efAOF_rad);

    // Stall logic (ported)
    if (((pitch < AOA) && (AOA < 0)) && (h_speed_mph < STALL_SPEED_MPH)) {
      if ((pitch - AOA) < -20) stall = true;
    }
    if (stall) {
      if (pitch > 30) stall = false;
      else pitch++;
    }
  }

  function inertialDamp() {
    // At low speeds, the speed-scaled control torques are small; overly aggressive damping
    // can zero out the resulting small angular deltas and make controls feel "dead".
    // Reduce damping a bit at low speed while airborne to preserve responsiveness.
    const eff = airborne ? clamp(h_speed_mph / CTRL_EFF_SPEED_MPH_MIN, 0.35, 1.0) : 1.0;
    const dampDiv = 10 / eff; // larger => less damping
    const eps = airborne ? 0.003 : 0.01;
    if (deltaVect.dPitch) {
      deltaVect.dPitch -= deltaVect.dPitch / dampDiv;
      if (((deltaVect.dPitch > 0) && (deltaVect.dPitch < eps)) ||
          ((deltaVect.dPitch < 0) && (deltaVect.dPitch > -eps))) {
        deltaVect.dPitch = 0;
      }
    }
    if (deltaVect.dYaw) {
      deltaVect.dYaw -= deltaVect.dYaw / dampDiv;
      if (((deltaVect.dYaw > 0) && (deltaVect.dYaw < eps)) ||
          ((deltaVect.dYaw < 0) && (deltaVect.dYaw > -eps))) {
        deltaVect.dYaw = 0;
      }
    }
    if (deltaVect.dRoll) {
      deltaVect.dRoll -= deltaVect.dRoll / dampDiv;
      if (((deltaVect.dRoll > 0) && (deltaVect.dRoll < eps)) ||
          ((deltaVect.dRoll < 0) && (deltaVect.dRoll > -eps))) {
        deltaVect.dRoll = 0;
      }
    }
  }

  function calcTurnRate() {
    let torque = 0.0;
    if ((roll > 0) && (roll <= 90)) torque = (roll * 0.00050);
    else if ((roll < 0) && (roll >= -90)) torque = (roll * 0.00050);
    return torque;
  }

  function calcROC(loopTimeMs) {
    const ctrlSpeedMph = airborne ? Math.max(h_speed_mph, CTRL_EFF_SPEED_MPH_MIN) : h_speed_mph;
    let torque;
    const dtS = loopTimeMs / 1000;
    if (airborne) {
      if (aileron_pos !== 0) {
        torque = ((ctrlSpeedMph * aileron_pos) / 10000);
        if (deltaVect.dRoll !== (torque * loopTimeMs)) deltaVect.dRoll += torque * AILERON_GAIN;
      }
    }
    if (elevator_pos !== 0) {
      torque = ((ctrlSpeedMph * elevator_pos) / 10000);
      if ((!airborne) && (torque > 0)) torque = 0;
      if (deltaVect.dPitch !== (torque * loopTimeMs)) deltaVect.dPitch += torque * ELEVATOR_GAIN;
    }

    // --- Longitudinal velocity stability (GA-like) ---
    // Pitch responds to speed error around a trim speed (set by throttle), producing a
    // lightly damped phugoid-like return when the yoke is released.
    if (airborne) {
      const trimMph = trimSpeedMphFromThrottle();
      const speedErr = h_speed_mph - trimMph; // +fast, -slow

      // Speed stability: fast -> pitch up (negative dPitch); slow -> pitch down (positive dPitch).
      // Units: deg/s per mph.
      const SPEED_STAB = 0.0065;
      const stabRateFromSpeed = -SPEED_STAB * speedErr;

      // Static pitch stiffness toward a small nose-up cruise attitude (helps separation of modes).
      // Units: deg/s per deg.
      const PITCH_EQ = -2.0;
      const PITCH_STIFF = 0.04;
      const stabRateFromPitch = -(pitch - PITCH_EQ) * PITCH_STIFF;

      deltaVect.dPitch += (stabRateFromSpeed + stabRateFromPitch) * dtS;

      // Pitch-rate damping (short-period): oppose pitch rate.
      // Units: 1/s applied to the pitch-rate state (deltaVect.dPitch).
      const PITCH_RATE_DAMP = 0.35;
      deltaVect.dPitch *= Math.exp(-PITCH_RATE_DAMP * dtS);
    }
    if (ctrlSpeedMph) {
      torque = 0.0;
      if (rudder_pos !== 0) torque = -((ctrlSpeedMph * rudder_pos) / 10000) * RUDDER_GAIN;
      torque += calcTurnRate();
      if (deltaVect.dYaw !== (torque * loopTimeMs)) deltaVect.dYaw += torque * 1.5;
    }

    // --- Lateral-directional stability (roll mode + dutch roll feel + weak spiral) ---
    if (airborne && dtS > 0) {
      // Treat dRoll/dYaw as rate-like states (deg per step -> deg/s), shape, then convert back.
      let p = deltaVect.dRoll / dtS; // roll rate (deg/s)
      let r = deltaVect.dYaw / dtS;  // yaw rate  (deg/s)

      // Roll mode: strong roll-rate damping.
      p *= Math.exp(-ROLL_RATE_DAMP * dtS);

      // Weakly stable spiral: slow wings-level tendency (tens of seconds).
      const absRoll = Math.abs(roll);
      const levelK = BANK_LEVEL_SLOW + BANK_LEVEL_FAST * clamp((absRoll - 20) / 50, 0, 1);
      p += (-(roll) * levelK) * dtS; // p_dot = -levelK*roll

      // Dutch roll feel: coupled yaw↔roll rates with yaw damping so it dies out in a few cycles.
      // Roll rate excites yaw (adverse yaw/dihedral coupling); yaw rate excites roll (dihedral effect).
      r += (DUTCH_K_YAW_FROM_ROLLRATE * p) * dtS;
      p += (DUTCH_K_ROLL_FROM_YAWRATE * r) * dtS;
      r *= Math.exp(-YAW_RATE_DAMP * dtS);

      // Adverse yaw from ailerons (nose yaws opposite to commanded roll).
      if (aileron_pos !== 0) {
        const ayStep = -((ctrlSpeedMph * aileron_pos) / 10000) * ADVERSE_YAW_GAIN; // deg/step
        r += ayStep / dtS; // convert to deg/s contribution
      }

      deltaVect.dRoll = p * dtS;
      deltaVect.dYaw = r * dtS;
    }

    // Hard caps on angular deltas (deg per simulation step) to prevent runaway rates
    // in the discrete-time port.
    deltaVect.dRoll  = clamp(deltaVect.dRoll,  -1.2, 1.2);
    deltaVect.dPitch = clamp(deltaVect.dPitch, -1.0, 1.0);
    deltaVect.dYaw   = clamp(deltaVect.dYaw,   -1.2, 1.2);
  }

  function applyRots() {
    roll += deltaVect.dRoll;
    yaw += deltaVect.dYaw;
    pitch += (deltaVect.dPitch * Math.cos(rads(roll)));
    yaw += -(deltaVect.dPitch * Math.sin(rads(roll)));

    // bounds roll/yaw to [-180..180]
    if (roll > 180) roll = -180 + (roll - 180);
    else if (roll < -180) roll = 180 + (roll + 180);
    if (yaw > 180) yaw = -180 + (yaw - 180);
    else if (yaw < -180) yaw = 180 + (yaw + 180);

    // special case pitch past vertical
    if ((pitch > 90) || (pitch < -90)) {
      if (roll >= 0) roll -= 180;
      else roll += 180;
      if (yaw >= 0) yaw -= 180;
      else yaw += 180;
      if (pitch > 0) pitch = (180 - pitch);
      else pitch = (-180 - pitch);
    }

    // damp close to zero (avoid aggressive "auto-level" feel at low speed)
    if ((pitch > -0.2) && (pitch < 0.2)) pitch = 0;
    if ((roll > -0.2) && (roll < 0.2)) roll = 0;
    if ((yaw > -0.2) && (yaw < 0.2)) yaw = 0;
  }

  function integratePosition(loopTimeMs) {
    // Port the simplified rotation path in RunFModel (roll rotation omitted in v2.1).
    // IMPORTANT: In the original port, vertical displacement was derived by rotating the
    // forward step by efAOF. That makes altitude changes vanish when forward speed is low
    // (delta_z_ft ~ 0), even if gravity is pulling down. Here we apply the vertical
    // displacement directly (v_speed_ft is already "feet per loop") so gravity always works.
    const newY_ft = v_speed_ft;   // vertical displacement per loop (ft)
    const newZ_ft = delta_z_ft;   // forward displacement per loop (ft)

    // Rotate in Y by yaw. Add a small "crab/slip" track offset from rudder command so you can
    // correct lateral drift more easily without needing large heading changes (feels like
    // smaller lateral inertia).
    const yawRad = rads(yaw);
    const SLIP_DEG_MAX = 10; // max track offset from rudder command when airborne
    const trackRad = yawRad + (airborne ? (rudder_cmd * SLIP_DEG_MAX * C) : 0);
    const dX_ft = (newZ_ft * Math.sin(trackRad));
    const dFwd_ft = (newZ_ft * Math.cos(trackRad));

    // Apply to metric positions.
    // Convention used everywhere else in this HTML port (HUD/camera):
    // 0° = +Y, 90° = +X, 180° = -Y, 270° = -X.
    // So positive yaw increases +X.
    PX += dX_ft * FT_TO_M;
    PY += dFwd_ft * FT_TO_M;
    PZ += newY_ft * FT_TO_M;

    // Update heading for UI
    AD = wrap360(yaw < 0 ? yaw + 360 : yaw);

    // Airborne flag (simple): becomes airborne once altitude > 0
    if ((!airborne) && (PZ > 0)) airborne = true;
  }

  function stepPhysics(dt) {
    const loopTimeMs = Math.max(1, dt * 1000);

    // C++ ordering: power/flight dynamics, damping, ROC, apply rotations, integrate.
    calcPowerDyn(loopTimeMs);
    calcFlightDyn(loopTimeMs);
    inertialDamp();
    calcROC(loopTimeMs);
    applyRots();
    integratePosition(loopTimeMs);

    // Derive velocities for wind + instruments from current state
    const speedMps = Math.max(0, h_speed_mph * MPH_TO_MPS);
    const ra = AD * C;
    VX = speedMps * Math.sin(ra);
    VY = speedMps * Math.cos(ra);
    VZ = v_speed_ft * FT_TO_M / dt; // ft/loop -> m/s (approx; avoids re-deriving from efAOF)

    GX = VX + WX;
    GY = VY + WY;
    GZ = VZ;

    // Integrate wind drift using metric velocities (keeps old UI behavior).
    // Note: primary position integration already happened via C++ model (still-air).
    PX += WX * dt;
    PY += WY * dt;

    // Terrain / ground contact:
    // - If you hit terrain above runway altitude, it's always fatal.
    // - Only safe contact is at runway altitude (<= 0).
    if (started && USE_THREE_WORLD && three && three.terrainInfo) {
      const gAlt = groundAltitudeM(PX, PY);
      if (PZ <= gAlt) {
        if (gAlt > 0.5) {
          finishTerrainCrash(gAlt);
          return;
        }
        // Safe contact at/under runway altitude: treat as landing event.
        PZ = 0;
        finishLanding();
        return;
      }
    } else {
      // Fallback: flat ground at runway altitude.
      if (PZ <= 0) {
        PZ = 0;
        finishLanding();
        return;
      }
    }
  }

  function finishLanding() {
    keysDown.clear();
    running = false;
    ended = true;

    // Distance to runway reference point (meters). Keeps DRIFT and DISTANCE consistent:
    // DISTANCE is always >= |DRIFT|.
    const dxr = PX;
    const dyr = PY - RUNWAY_REF_Y;
    const dist = Math.sqrt(dxr*dxr + dyr*dyr);
    const vvMps = Math.max(0, h_speed_mph * MPH_TO_MPS);
    const vvKmh = vvMps * MPS_TO_KMH;
    const onRunway =
      (Math.abs(PX) <= WR) &&
      (PY >= RUNWAY_START_Y) &&
      (PY <= RUNWAY_END_Y);

    // Reuse original scoring thresholds (tuned for the landing mini-game).
    if (Math.abs(roll) > RT || pitch > TP || pitch < 0 || vvMps > 80) {
      endMessage = [
        "LAMENTAMOS INFORMAR QUE O VOO PJ26 SOFREU UM GRAVE ACIDENTE.",
        "NAO HA SOBREVIVENTES."
      ];
    } else if (!onRunway) {
      if (vvMps < 40) endMessage = ["VOCE POUSOU FORA DA PISTA.", "COMO SUA VELOCIDADE ERA BAIXA,",
        " QUASE NADA ACONTECEU."];
      else if (vvMps < 80) endMessage = ["VOCE POUSOU FORA DA PISTA.", "ENTRE MORTOS E FERIDOS,",
        " SALVARAM-SE TODOS."];
      else endMessage = ["VOCE POUSOU FORA DA PISTA.", "NINGUEM SOBREVIVE A UM POUSO",
        " NESTA VELOCIDADE."];
    } else {
      endMessage = ["PARABENS!", "ATERRISSAGEM BEM SUCEDIDA."];
    }

    endMessage.push("");
    endMessage.push("VALORES RELATIVOS AO POUSO:");
    endMessage.push(`VELOCIDADE DO AR = ${Math.floor(vvKmh)} KM/H`);
    endMessage.push(`DISTANCIA        = ${Math.floor(dist)} M`);
    endMessage.push(`INCLINACAO FRONTAL= ${Math.floor(pitch)}`);
    endMessage.push(`INCLINACAO LATERAL= ${Math.floor(roll)}`);
    endMessage.push(`ROTACAO DO MOTOR  = ${Math.floor(rpm)} RPM`);
    endMessage.push(`DESVIO DA PISTA   = ${Math.floor(PX)} M`);
    endMessage.push(`DIRECAO           = ${Math.floor(AD)} GRAUS`);
    endMessage.push("");
    endMessage.push("REINICIAR? (R/N)");
  }

  function finishTerrainCrash(groundAlt) {
    keysDown.clear();
    running = false;
    ended = true;
    stopEngineAudio();

    endMessage = [];
    endMessage.push("CRASH (TERRAIN)");
    endMessage.push(`ALTITUDE= ${Math.floor(PZ)} M`);
    endMessage.push(`TERRAIN = ${Math.floor(groundAlt)} M`);
    endMessage.push(`AIRSPEED = ${Math.floor(Math.max(0, h_speed_mph * MPH_TO_MPS) * MPS_TO_KMH)} KM/H`);
    endMessage.push("");
    endMessage.push("REINICIAR? (R/N)");
  }

  function computeRunwayBearingRB() {
    if (!started) return 0;
    // Bearing from aircraft to a runway reference point on the drawn runway strip.
    // Heading convention: 0° = +Y, clockwise positive, as used by the HUD.
    const dx = 0 - PX;
    const dy = RUNWAY_REF_Y - PY;
    if (dx === 0 && dy === 0) return 0;
    const RB = Math.atan2(dx, dy) / C;
    return wrap360(RB);
  }

  // --- TOP WINDOW ---
  function drawWindowAndRunway() {
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;

    // Full-width top window (no lateral limits): x = 0..255
    const winTop = 0;
    const winBot = TOP_WINDOW_H;
    line(0, winTop, 255, winTop);
    line(255, winTop, 255, winBot);
    if (!IS_MOBILE) line(255, winBot, 0, winBot);
    line(0, winBot, 0, winTop);

    const xmin = 0, xmax = 255, ymin = 1, ymax = (TOP_WINDOW_H - 1);
    const vw = (xmax - xmin);
    const vh = (ymax - ymin);
    const intr = {
      cx: (xmin + xmax) * 0.5,
      cy: (ymin + ymax) * 0.5,
      f: (vw * 0.5) / Math.tan(60 * C * 0.5),
      nearZ: 1.0
    };

    // Camera pose: use aircraft position and attitude.
    // Model convention: pitch increases when pitching down, so invert to get "nose up".
    const camPos = v3(PX, PY, PZ);
    const basis = computeCameraBasis(AD, -pitch * PITCH_RENDER_SCALE, roll);

    // Near plane: keep small. A large nearZ (like 1m) can slice the runway when low,
    // producing unstable polygons. We keep it small but non-zero to avoid blowups.
    intr.nearZ = Math.max(0.05, Math.min(0.2, camPos.z * 0.02));

    // Camera-correct horizon line: a*(X-cx)+b*(Y-cy)+c*f = 0
    // Keep coefficients so the ground-grid can extend up to the horizon.
    let horizonA = 0, horizonB = 0, horizonC = 0;
    {
      const worldUp = v3(0, 0, 1);
      const a = v3dot(basis.camRight, worldUp);
      const b = v3dot(basis.camDown, worldUp);
      const c = v3dot(basis.camFwd, worldUp);
      const A = a;
      const B = b;
      const Cc = c * intr.f - a * intr.cx - b * intr.cy;
      horizonA = A; horizonB = B; horizonC = Cc;
      const pts = lineRectIntersections(A, B, Cc, xmin, xmax, ymin, ymax);
      if (pts.length === 2) line(pts[0][0], pts[0][1], pts[1][0], pts[1][1]);
    }

    if (!started) return;

    // --- Ground grid as dots at intersections (500m spacing) on Z=0 ---
    ctx.save();
    ctx.fillStyle = "#9aa";
    ctx.globalAlpha = 0.55;
    const GRID = 500;

    function screenRayDirWorld(x, y) {
      // Camera ray through pixel (x,y). Camera coordinates: z forward, y down.
      const dx = (x - intr.cx) / intr.f;
      const dy = (y - intr.cy) / intr.f;
      // World dir = camRight*dx + camDown*dy + camFwd*1
      return v3add(v3add(v3mul(basis.camRight, dx), v3mul(basis.camDown, dy)), basis.camFwd);
    }

    function intersectRayWithGroundZ0(dirWorld) {
      // Ray: camPos + t*dirWorld, ground plane z=0.
      const eps = 1e-9;
      if (dirWorld.z >= -eps) return null; // not pointing toward ground
      const t = (0 - camPos.z) / dirWorld.z;
      if (!isFinite(t) || t <= 0) return null;
      return v3add(camPos, v3mul(dirWorld, t));
    }

    // Find a y coordinate just below the horizon (at screen center).
    let yH = null;
    if (Math.abs(horizonB) > 1e-9) {
      yH = -(horizonA * intr.cx + horizonC) / horizonB;
    }
    const ySample = clamp((yH == null ? intr.cy : (yH + 1)), ymin, ymax);

    // Estimate "visible-to-horizon" ground distance by intersecting a few rays
    // just below the horizon and at the bottom of the viewport.
    const samplePts = [
      [xmin, ySample],
      [intr.cx, ySample],
      [xmax, ySample],
      [xmin, ymax],
      [intr.cx, ymax],
      [xmax, ymax],
    ];
    let farDist = 0;
    const groundHits = [];
    for (const [sx, sy] of samplePts) {
      const hit = intersectRayWithGroundZ0(screenRayDirWorld(sx, sy));
      if (!hit) continue;
      groundHits.push(hit);
      const d = Math.hypot(hit.x - PX, hit.y - PY);
      if (isFinite(d) && d > farDist) farDist = d;
    }
    // Safety margins & caps (avoid huge line counts while still reaching the horizon visually).
    farDist = Math.min(Math.max(farDist * 1.15, 3000), 250000);

    // Also ensure the grid spans at least twice the distance to the runway (origin).
    const distToRunway = Math.hypot(PX, PY);
    const RANGE = Math.max(farDist, 2 * distToRunway);

    // Prefer bounding box of actually visible ground hits to keep point count reasonable.
    let minGX = PX - RANGE, maxGX = PX + RANGE, minGY = PY - RANGE, maxGY = PY + RANGE;
    if (groundHits.length >= 2) {
      minGX = Math.min(...groundHits.map(p => p.x));
      maxGX = Math.max(...groundHits.map(p => p.x));
      minGY = Math.min(...groundHits.map(p => p.y));
      maxGY = Math.max(...groundHits.map(p => p.y));
      // Expand a bit so we don't get holes at the edges due to rounding/clipping.
      minGX -= GRID; maxGX += GRID;
      minGY -= GRID; maxGY += GRID;
    }
    // Always include a local region around the aircraft so dots appear close-by
    // and to the sides, regardless of the far/horizon sampling.
    const LOCAL_X = 4000;
    const LOCAL_Y_BACK = 1000;
    const LOCAL_Y_FWD = 8000;
    minGX = Math.min(minGX, PX - LOCAL_X);
    maxGX = Math.max(maxGX, PX + LOCAL_X);
    minGY = Math.min(minGY, PY - LOCAL_Y_BACK);
    maxGY = Math.max(maxGY, PY + LOCAL_Y_FWD);

    const x0 = Math.floor(minGX / GRID) * GRID;
    const x1 = Math.ceil(maxGX / GRID) * GRID;
    const y0 = Math.floor(minGY / GRID) * GRID;
    const y1 = Math.ceil(maxGY / GRID) * GRID;

    function drawWorldDot(wx, wy) {
      const pc = worldToCamera(v3(wx, wy, 0), camPos, basis);
      if (pc.z < intr.nearZ) return;
      const s = projectCamToScreen(pc, intr);
      if (!s) return;
      if (s[0] < xmin || s[0] > xmax || s[1] < ymin || s[1] > ymax) return;
      dotSoft(s[0], s[1]);
    }

    // Draw a projected world-space segment (used for runway centerline dashes).
    function drawWorldSegment(pw1, pw2) {
      let p1c = worldToCamera(pw1, camPos, basis);
      let p2c = worldToCamera(pw2, camPos, basis);
      const clipped = clipSegmentToNearPlane(p1c, p2c, intr.nearZ);
      if (!clipped) return;
      p1c = clipped[0]; p2c = clipped[1];
      const s1 = projectCamToScreen(p1c, intr);
      const s2 = projectCamToScreen(p2c, intr);
      if (!s1 || !s2) return;
      const seg = clipLineToRect(s1[0], s1[1], s2[0], s2[1], xmin, ymin, vw, vh);
      if (seg) lineSnapped(seg[0], seg[1], seg[2], seg[3]);
    }

    // Budget dots per frame to avoid huge loops at high altitude / far horizon.
    const nx = Math.max(1, Math.floor((x1 - x0) / GRID) + 1);
    const ny = Math.max(1, Math.floor((y1 - y0) / GRID) + 1);
    // Higher target => denser dots (less skipping).
    const targetDots = 80000;
    const stride = Math.max(1, Math.ceil(Math.sqrt((nx * ny) / targetDots)));
    const step = GRID * stride;

    // Draw a dense local patch first (no skipping), so dots show up near the aircraft.
    const lx0 = Math.floor((PX - LOCAL_X) / GRID) * GRID;
    const lx1 = Math.ceil((PX + LOCAL_X) / GRID) * GRID;
    const ly0 = Math.floor((PY - LOCAL_Y_BACK) / GRID) * GRID;
    const ly1 = Math.ceil((PY + LOCAL_Y_FWD) / GRID) * GRID;
    for (let y = ly0; y <= ly1; y += GRID) {
      for (let x = lx0; x <= lx1; x += GRID) {
        drawWorldDot(x, y);
      }
    }

    // Then draw the far/horizon region with a stride (skipping) for performance.
    for (let y = y0; y <= y1; y += step) {
      for (let x = x0; x <= x1; x += step) {
        drawWorldDot(x, y);
      }
    }
    ctx.restore();

    // --- Runway as a true world rectangle on Z=0 ---
    // The landing game measures distance to the runway touchdown point at (0,0).
    // To keep the runway stable on approach (PY starts negative), define the runway
    // starting at Y=0 and extending forward (+Y), rather than centered at the origin.
    ctx.strokeStyle = "#fff";
    // (RUNWAY_START_Y / RUNWAY_END_Y are defined above)
    const rw = WR;
    const runwayWorld = [
      v3(-rw, RUNWAY_START_Y, 0),
      v3( rw, RUNWAY_START_Y, 0),
      v3( rw, RUNWAY_END_Y, 0),
      v3(-rw, RUNWAY_END_Y, 0),
    ];

    const runwayCam = runwayWorld.map(p => worldToCamera(p, camPos, basis));
    const runwayCamClipped = clipPolygonToNearPlane(runwayCam, intr.nearZ);
    if (runwayCamClipped.length >= 3) {
      const runwayScr = runwayCamClipped.map(p => projectCamToScreen(p, intr));
      // If any vertex failed projection (should be rare after near-plane clipping),
      // bail out rather than drawing a malformed polygon that can flicker.
      if (runwayScr.some(p => !p)) return;
      const runwayPoly = clipPolygonRect(runwayScr, xmin, xmax, ymin, ymax);
      if (runwayPoly.length >= 3) {
        // Mask the grid inside the runway by filling with background color.
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.moveTo(runwayPoly[0][0], runwayPoly[0][1]);
        for (let i = 1; i < runwayPoly.length; i++) ctx.lineTo(runwayPoly[i][0], runwayPoly[i][1]);
        ctx.closePath();
        ctx.fill();

        // Add dense dots on the runway surface so it stays readable up close.
        // (World-space lattice projected into screen space.)
        ctx.save();
        ctx.fillStyle = "#cfcfcf";
        ctx.globalAlpha = 0.85;
        const RUNWAY_DOT_STEP_X = 10; // meters across runway width
        const RUNWAY_DOT_STEP_Y = 20; // meters along runway length
        const RUNWAY_DOT_PX = 2;      // device pixels
        function drawRunwayDot(wx, wy) {
          const pc = worldToCamera(v3(wx, wy, 0), camPos, basis);
          if (pc.z < intr.nearZ) return;
          const s = projectCamToScreen(pc, intr);
          if (!s) return;
          if (s[0] < xmin || s[0] > xmax || s[1] < ymin || s[1] > ymax) return;
          dotSoftPx(s[0], s[1], RUNWAY_DOT_PX);
        }
        for (let yy = RUNWAY_START_Y; yy <= RUNWAY_END_Y; yy += RUNWAY_DOT_STEP_Y) {
          for (let xx = -rw; xx <= rw; xx += RUNWAY_DOT_STEP_X) {
            drawRunwayDot(xx, yy);
          }
        }
        ctx.restore();

        // Outline runway.
        ctx.strokeStyle = "#fff";
        drawPolygon(runwayPoly);

        // Centerline dashes (world space along runway center x=0)
        const dashStep = 100;
        const dashLen = 40;
        for (let yy = RUNWAY_START_Y; yy < RUNWAY_END_Y; yy += dashStep) {
          const a = v3(0, yy, 0);
          const b = v3(0, Math.min(RUNWAY_END_Y, yy + dashLen), 0);
          drawWorldSegment(a, b);
        }
      }
    }
  }

  // --- INSTRUMENTS ---
  function drawInstrumentsAndHUD() {
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;
    ctx.fillStyle = "#fff";

    const UI_Y_OFF = 5; // move all instruments down

    const yDial = 120 + UI_Y_OFF; // dial centers
    const dialR = 16; // match TURN coordinator diameter
    const cxAirspeed = 28;
    const cxHorizon  = 76;
    const cxAltitude = 124;
    const cxVario    = 172;
    const cxRpm      = 220;

    const dials = [
      { cx: cxAirspeed, top: "AIRSPEED KM/H",  bot: ""  },
      { cx: cxHorizon,  top: "HORIZ",     bot: ""   },
      { cx: cxAltitude, top: "ALTITUDE",  bot: ""    },
      { cx: cxVario,    top: "VARIO M/S",     bot: ""         },
      { cx: cxRpm,      top: "RPM",       bot: ""     },
    ];

    for (const d of dials) dialBezel(d.cx, yDial, dialR);
    for (const d of dials) {
      for (let k = 0; k < 10; k++) {
        const a = k * PI / 5;
        line(d.cx + (dialR - 1) * Math.sin(a), yDial - (dialR - 1) * Math.cos(a),
             d.cx + (dialR - 3) * Math.sin(a), yDial - (dialR - 3) * Math.cos(a));
      }
    }

    const yTopLabel  = 92 + UI_Y_OFF;  // moved with dials
    const yDialValue = 100 + UI_Y_OFF;  // moved with dials
    // Two-line bottom label area: label, unit, value.
    const yBotLabel  = 158 + UI_Y_OFF;
    const yBotUnit   = 166 + UI_Y_OFF;
    const yBotValue  = 186 + UI_Y_OFF;

    // Keep text comfortably away from the analog dials.
    // (Especially important now that some labels include units.)
    const FONT_LABEL = "7px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const FONT_VALUE = "8px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const FONT_UNIT  = "6px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

    ctx.font = FONT_LABEL;
    for (const d of dials) {
      textCentered(d.cx, yTopLabel, d.top);
      textCentered(d.cx, yBotLabel, d.bot);
    }
    // (Bottom labels/units for RUNWAY/DRIFT/DIST were replaced by a compact text block.)

    // Heading indicator (compass rose) in the AIRSPEED column bottom area.
    // Driven by current direction/heading value (AD). Keep minimalist and keep the digital value.
    {
      const cx = cxAirspeed;
      // Move it up a bit (no BEARING label anymore) and match the other dial sizes.
      const cy = yBotLabel + 4;
      const r = dialR;

      dialBezel(cx, cy, r);

      // Rotating compass card: rotate opposite to aircraft heading so the top shows current direction.
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(-AD * C);

      // Tick marks: minor every 30°, major at cardinals.
      for (let deg = 0; deg < 360; deg += 30) {
        const a = deg * C;
        const isMajor = (deg % 90) === 0;
        const r1 = r - (isMajor ? 1 : 2);
        const r2 = r;
        line(r1 * Math.sin(a), -r1 * Math.cos(a), r2 * Math.sin(a), -r2 * Math.cos(a));
      }

      // Cardinal letters.
      ctx.font = FONT_UNIT;
      const card = [
        ["N", 0],
        ["E", 90],
        ["S", 180],
        ["W", 270],
      ];
      for (const [ch, deg] of card) {
        const a = deg * C;
        const tx = (r - 4) * Math.sin(a);
        const ty = -(r - 4) * Math.cos(a) + 2; // baseline tweak
        textCentered(tx, ty, ch);
      }
      ctx.restore();

      // Fixed reference (aircraft): simple airplane marker (no rotation).
      const w = r * 0.55;
      const h = r * 0.35;
      // wings
      line(cx - w, cy, cx + w, cy);
      // fuselage
      line(cx, cy - h, cx, cy + h);
      // tail
      line(cx - r * 0.18, cy + h * 0.5, cx + r * 0.18, cy + h * 0.5);
    }

    const RB = started ? computeRunwayBearingRB() : 0;
    // Distance to runway reference point (meters)
    const dist = started ? Math.sqrt(PX*PX + (PY - RUNWAY_REF_Y)*(PY - RUNWAY_REF_Y)) : 0;
    const driftM = started ? PX : 0;

    // Compact nav/status readout in the space freed by moving TURN away from VARIO:
    // label on the left, value aligned to the right.
    {
      // Column-align: labels under VARIO, values under RPM.
      const xLabel = cxVario;
      const xValue = cxRpm;
      const y0 = 150 + UI_Y_OFF;
      const dy = 12;
      ctx.font = FONT_LABEL;
      textCentered(xLabel, y0, "RUNAWAY DEG");
      textCentered(xLabel, y0 + dy, "DRIFT (M)");
      textCentered(xLabel, y0 + dy * 2, "DIST (M)");

      ctx.font = FONT_VALUE;
      const v1 = `${Math.floor(RB)}`;
      const v2 = `${Math.floor(driftM)}`;
      const v3 = `${Math.floor(dist)}`;
      textCentered(xValue, y0, v1);
      textCentered(xValue, y0 + dy, v2);
      textCentered(xValue, y0 + dy * 2, v3);
    }

    // ILS (minimal): below ALTITUDE dial.
    // Localizer: lateral deviation based on PX (meters) vs runway centerline.
    // Glideslope: vertical deviation vs a 3° glidepath to the runway threshold (Y=0).
    {
      const cx = cxAltitude;
      const cy = yBotLabel + 4;
      const r = dialR;

      dialBezel(cx, cy, r);

      // Label below the dial, aligned with the compass (bearing) digital readout row.
      ctx.font = FONT_LABEL;
      textCentered(cx, yBotValue, "ILS");

      if (started) {
        const LOC_FULL_SCALE_M = WR; // 50m => full-scale equals runway half-width (matches evaluation)
        const loc = clamp(PX / LOC_FULL_SCALE_M, -1, 1);

        const glideDeg = 3.0;
        const dToThr = Math.max(0, -PY); // meters to runway threshold while on approach
        const desiredAlt = Math.tan(glideDeg * C) * dToThr;
        const gsErr = PZ - desiredAlt; // meters (positive = above path)

        const GS_FULL_SCALE_M = 50; // game-friendly
        const gs = clamp(gsErr / GS_FULL_SCALE_M, -1, 1);

        // Markers (vertical ticks instead of circles)
        const dotOff = r * 0.5;
        const dotStep = r * 0.22;
        const tickH = 1.0;
        for (const s of [-2, -1, 1, 2]) {
          // LOC markers (left/right)
          const xLoc = cx + s * dotStep;
          line(xLoc, cy - tickH, xLoc, cy + tickH);
          // GS markers (up/down) — also vertical ticks, centered on x=cx
          const yGs = cy + s * dotStep;
          line(cx, yGs - tickH, cx, yGs + tickH);
        }

        // Needles: vertical needle slides left/right (LOC); horizontal needle slides up/down (GS).
        const locX = cx + loc * dotOff;
        const gsY = cy - gs * dotOff;

        line(locX, cy - r * 0.65, locX, cy + r * 0.65);
        line(cx - r * 0.65, gsY, cx + r * 0.65, gsY);
      } else {
        // Centered needles when not started.
        line(cx, cy - r * 0.65, cx, cy + r * 0.65);
        line(cx - r * 0.65, cy, cx + r * 0.65, cy);
      }
    }

    const vvMps = Math.max(0, h_speed_mph * MPH_TO_MPS);
    const vvKmh = vvMps * MPS_TO_KMH;
    const vsMps = started ? (v_speed_ft * FT_TO_M / DT) : 0; // m/s (vertical)
    const VARIO_DIAL_MAX_MPS = 20.0; // analog scale only: -20..+20 m/s
    const vsNeedleMps = clamp(vsMps, -VARIO_DIAL_MAX_MPS, VARIO_DIAL_MAX_MPS);

    ctx.font = FONT_VALUE;
    textCentered(cxAirspeed, yDialValue, `${Math.floor(vvKmh)}`);
    textCentered(cxAltitude, yDialValue, `${Math.floor(PZ)}`);
    {
      const v = Math.round(vsMps);
      const s = v > 0 ? `+${v}` : `${v}`;
      textCentered(cxVario, yDialValue, s);
    }
    textCentered(cxRpm,      yDialValue, `${Math.floor(rpm)}`);

    // Airspeed dial: 0..400 km/h maps to 0..2π.
    const AIRSPEED_MAX_KMH = 400;
    needle(cxAirspeed, yDial, 14, clamp(vvKmh, 0, AIRSPEED_MAX_KMH) * 2 * PI / AIRSPEED_MAX_KMH);

    // Horizon dial
    {
      const cx = cxHorizon, cy = yDial;
      const r = dialR - 4;
      const theta = -roll * 2 * C;
      const dx = Math.cos(theta), dy = Math.sin(theta);
      const uiPitch = -pitch * PITCH_RENDER_SCALE;
      const x0 = cx, y0 = cy + uiPitch;

      // Dotted "ground" fill so sky/ground are distinguishable (minimalist).
      // Fill the side of the horizon line where (p - (x0,y0))·n > 0, with n = (-dy, dx).
      {
        const nx = -dy, ny = dx;
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, 2 * PI);
        ctx.clip();
        // Higher contrast + slightly larger dots so they remain visible at small dial sizes.
        ctx.fillStyle = "#fff";
        ctx.globalAlpha = 0.65;
        const step = 4;
        const dotPx = 2;
        for (let yy = cy - r; yy <= cy + r; yy += step) {
          for (let xx = cx - r; xx <= cx + r; xx += step) {
            const rx = xx - cx, ry = yy - cy;
            if (rx * rx + ry * ry > r * r) continue;
            const dist = (xx - x0) * nx + (yy - y0) * ny;
            if (dist > 0) dotSoftPx(xx, yy, dotPx);
          }
        }
        ctx.restore();
      }

      const fx = x0 - cx, fy = y0 - cy;
      const b = 2 * (fx * dx + fy * dy);
      const cc = (fx * fx + fy * fy) - r * r;
      const disc = b * b - 4 * cc;
      if (disc >= 0) {
        const s = Math.sqrt(disc);
        const t1 = (-b - s) / 2;
        const t2 = (-b + s) / 2;
        line(x0 + t1 * dx, y0 + t1 * dy, x0 + t2 * dx, y0 + t2 * dy);
      }

      let x = cx - 14, y = yDial;
      const segs = [[9,0],[5,5],[5,-5],[9,0]];
      for (const [sx, sy] of segs) {
        line(x, y, x + sx, y + sy);
        x += sx; y += sy;
      }
    }

    // Altitude needles (as in original)
    const TN = started ? (PZ / 1000) : 0;
    const UN = started ? (PZ - 1000 * Math.floor(TN)) : 0;
    needle(cxAltitude, yDial, 9,  TN * PI / 5);
    needle(cxAltitude, yDial, 14, UN * PI / 500);

    // Variometer (vertical speed indicator)
    {
      const cx = cxVario, cy = yDial;
      const r = dialR - 3;

      // Face text (keep simple; units match sim: m/s).
      ctx.font = "7px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      //textCentered(cx, cy - 3, "VERTICAL SPEED");
      // textCentered(cx, cy + 9, "M/S");
      // ctx.font = "8px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      // ctx.fillText("UP", cx - r + 2, cy - 2);
      // ctx.fillText("DN", cx - r + 2, cy + 10);

      // Needle: 0 points left. Positive climbs rotate over the top; negative over the bottom.
      const frac = clamp(Math.abs(vsNeedleMps) / VARIO_DIAL_MAX_MPS, 0, 1);
      const base = -PI / 2;
      const ang = vsNeedleMps >= 0 ? (base + frac * PI) : (base - frac * PI);
      ctx.font = FONT_VALUE;
      needle(cx, cy, 14, ang);
    }

    // Turn coordinator (minimalist): below VARIO.
    {
      // Move below the artificial horizon.
      const cx = cxHorizon;
      // Match the heading indicator vertical position.
      const cy = yBotLabel + 4;
      const r = 16;
      const PLANE_SCALE = 0.8; // overall airplane scale
      const WING_SCALE = 0.8;  // reduced wing span

      dialBezel(cx, cy, r);

      // Label below the dial, aligned with the ILS label row.
      ctx.font = FONT_LABEL;
      textCentered(cx, yBotValue, "TURN");

      // Reference marks (L/R standard rate).
      const m = r - 2;
      line(cx - m, cy, cx - m + 5, cy);
      line(cx + m, cy, cx + m - 5, cy);

      // Compute yaw rate (deg/s) from per-step delta.
      const yawRateDps = deltaVect.dYaw * SIM_HZ;

      // Standard rate turn (2 min) is ~3 deg/s.
      const stdRateDps = 3.0;
      const bankNeedleDeg = clamp(yawRateDps / stdRateDps, -1, 1) * 25;
      const bankNeedleRad = bankNeedleDeg * C;

      // Draw "airplane": wings + small fuselage. Rotate by turn indication.
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(bankNeedleRad);
      // wings
      line(-r * 0.85 * PLANE_SCALE * WING_SCALE, 0, r * 0.85 * PLANE_SCALE * WING_SCALE, 0);
      // fuselage
      line(0, -r * 0.15 * PLANE_SCALE, 0, r * 0.35 * PLANE_SCALE);
      // tail
      line(-r * 0.20 * PLANE_SCALE, r * 0.20 * PLANE_SCALE, r * 0.20 * PLANE_SCALE, r * 0.20 * PLANE_SCALE);
      ctx.restore();

      // Slip/skid "ball" (approx):
      // Compare actual yaw rate to coordinated-turn yaw rate from bank and speed.
      const speedMps = Math.max(1, h_speed_mph * MPH_TO_MPS);
      const bankRad = roll * C;
      const expectedYawDps = (G_MPS2 * Math.tan(bankRad) / speedMps) * (180 / PI);
      const slipDps = yawRateDps - expectedYawDps;

      // Ball track at bottom of dial.
      const trackY = cy + r * 0.55;
      const trackHalf = r * 0.55;
      // Center marks.
      line(cx - r * 0.10, trackY - 3, cx - r * 0.10, trackY + 3);
      line(cx + r * 0.10, trackY - 3, cx + r * 0.10, trackY + 3);

      const ballX = cx + clamp(slipDps / 3.0, -1, 1) * trackHalf;
      ctx.beginPath();
      ctx.arc(ballX, trackY, 3 * 0.8 * 0.5, 0, 2 * PI);
      ctx.fill();
    }

    // RPM needle (scaled to 0..~9000 mapped to 0..5*PI)
    // RPM needle: RPM_MAX maps to full scale.
    needle(cxRpm, yDial, 14, clamp(rpm / (RPM_MAX / 5), 0, 5) * PI / 5);

    ctx.font = FONT_VALUE;
    textCentered(cxAirspeed, yBotValue, `${Math.floor(started ? AD : 0)}`);
  }

  function drawEndScreen() {
    ctx.fillStyle = "rgba(0,0,0,0.92)";
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = "#fff";
    ctx.font = "10px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    let y = 18;
    for (const s of endMessage) {
      if (s === "") { y += 6; continue; }
      ctx.fillText(s, 10, y);
      y += 12;
      if (y > H - 10) break;
    }
  }

  // --- Mobile UI controls (drawn on the separate controls canvas) ---
  function _roundRectPathC(x, y, w, h, r) {
    if (!cctx) return;
    const rr = Math.min(r, w * 0.5, h * 0.5);
    cctx.beginPath();
    cctx.moveTo(x + rr, y);
    cctx.arcTo(x + w, y, x + w, y + h, rr);
    cctx.arcTo(x + w, y + h, x, y + h, rr);
    cctx.arcTo(x, y + h, x, y, rr);
    cctx.arcTo(x, y, x + w, y, rr);
    cctx.closePath();
  }
  function _lineC(x1, y1, x2, y2) {
    if (!cctx) return;
    cctx.lineWidth = 1 / _cPxScale;
    cctx.beginPath();
    cctx.moveTo(x1, y1);
    cctx.lineTo(x2, y2);
    cctx.stroke();
  }
  function _textCenteredC(x, y, s) {
    if (!cctx) return;
    cctx.textAlign = "center";
    cctx.textBaseline = "middle";
    cctx.fillText(s, x, y);
  }

  function renderMobileControlsCanvas() {
    if (!IS_MOBILE) return;
    if (!controlsCanvas || !cctx) return;
    if (ended) return;

    resizeControlsCanvasToWindowIfNeeded();
    cctx.setTransform(_cScaleX, 0, 0, _cScaleY, 0, 0);
    cctx.clearRect(0, 0, W, H);

    const L = mobileLayout();

    cctx.save();
    cctx.globalAlpha = 0.95;
    cctx.strokeStyle = "#fff";
    cctx.fillStyle = "#000";
    cctx.lineWidth = 1;

    const font = "10px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    cctx.font = font;

    // Stick (right)
    {
      const { cx, cy, r } = L.stick;
      cctx.globalAlpha = 0.9;
      cctx.beginPath(); cctx.arc(cx, cy, r, 0, 2 * PI); cctx.stroke();
      _lineC(cx - r, cy, cx + r, cy);
      _lineC(cx, cy - r, cx, cy + r);
      const kx = cx + mobileCtl.stickX * r * 0.65;
      const ky = cy + mobileCtl.stickY * r * 0.65;
      cctx.beginPath(); cctx.arc(kx, ky, 9, 0, 2 * PI); cctx.stroke();
      _textCenteredC(cx, Math.max(8, cy - r - 10), "STICK");
    }

    // Throttle
    {
      const t = L.throttle;
      _roundRectPathC(t.x, t.y, t.w, t.h, 6);
      cctx.stroke();
      const knobY = t.y + (1 - mobileCtl.throttleN) * t.h;
      _roundRectPathC(t.x - 6, knobY - 8, t.w + 12, 16, 7);
      cctx.stroke();
      _textCenteredC(t.x + t.w * 0.5, Math.max(8, t.y - 10), "THROTTLE");
    }

    // Rudder
    {
      const r = L.rudder;
      const w = (r.x1 - r.x0);
      _roundRectPathC(r.x0, r.y, w, r.h, 6);
      cctx.stroke();
      const cx = (r.x0 + r.x1) * 0.5;
      // Draw knob to follow finger direction (control sign is handled in the mapping).
      const knobX = cx - mobileCtl.rudderN * (w * 0.5);
      _roundRectPathC(knobX - 14, r.y - 6, 28, r.h + 12, 7);
      cctx.stroke();
      _textCenteredC(cx, Math.max(8, r.y - 10), "RUDDER");
    }

    // Buttons
    {
      const drawBtn = (b, label, active) => {
        _roundRectPathC(b.x, b.y, b.w, b.h, 8);
        cctx.stroke();
        if (active) {
          cctx.save();
          cctx.globalAlpha = 0.25;
          cctx.fill();
          cctx.restore();
        }
        // Ensure text is visible (controls canvas background is black).
        cctx.save();
        cctx.fillStyle = "#fff";
        _textCenteredC(b.x + b.w * 0.5, b.y + b.h * 0.5, label);
        cctx.restore();
      };
      drawBtn(L.brakeBtn, "BREAK", !!brake);
      drawBtn(L.muteBtn, "MUTE", !!audioMuted);
    }

    cctx.restore();
  }

  function render() {
    clearScreen();
    ctx.strokeStyle = "#fff";
    ctx.fillStyle = "#fff";
    if (USE_THREE_WORLD) {
      renderThreeWorld();
    } else {
      drawWindowAndRunway();
    }
    drawInstrumentPanelBackground();
    drawInstrumentsAndHUD();
    if (ended) drawEndScreen();

    // Separate mobile controls canvas (below sim).
    renderMobileControlsCanvas();
  }

  let last = performance.now();
  let acc = 0;

  function loop(now) {
    const dtReal = (now - last) / 1000;
    last = now;
    acc += Math.min(dtReal, 0.25);

    let steps = 0;
    while (acc >= DT && steps < MAX_CATCHUP_STEPS) {
      if (running && !ended) {
        updateControls(DT);
        stepPhysics(DT);
      }
      acc -= DT;
      steps++;
    }

    // Drive engine audio from sim state.
    if (audioEngine && audioCtx && audioCtx.state === "running") {
      audioEngine.setBlades(2);
      const throttle = clamp01(throttle_pos / 75);
      const airspeed = Math.max(0, h_speed_mph * MPH_TO_MPS);
      audioEngine.setState({ rpm, throttle, airspeed });
    }
    if (ended) stopEngineAudio();

    render();
    requestAnimationFrame(loop);
  }

  document.getElementById("startBtn").addEventListener("click", () => {
    const ws = clamp(parseFloat(document.getElementById("windSpeed").value || "10"), 1, 50);
    const wd = wrap360(parseFloat(document.getElementById("windDir").value || "0"));
    startEngineAudio();
    started = true;
    // New random terrain per flight start.
    TERRAIN_SEED = (Date.now() ^ ((Math.random() * 0xffffffff) >>> 0)) >>> 0;
    if (!three) initThreeWorld();
    resetGame(ws, wd);
  });

  setDemoScreenState();
  initThreeWorld();
  render();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>


