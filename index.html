<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FlightRTSim – C++ Flight Model (HTML5)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#000; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { max-width: 980px; margin:0 auto; padding:16px; display:grid; gap:12px; }
    .panel { background:#000; border:1px solid #444; border-radius:10px; padding:12px; }
    label { display:block; margin:8px 0 4px; }
    input { width:170px; padding:6px 8px; background:#050505; border:1px solid #777; border-radius:6px; color:#fff; }
    button { padding:8px 10px; border-radius:8px; border:1px solid #999; background:#111; color:#fff; cursor:pointer; }
    button:hover { background:#222; }
    canvas { display:block; width:100%; aspect-ratio: 4 / 3; background:#000; border:1px solid #fff; border-radius:4px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:end; }
    .hint { margin-top:8px; font-size:0.95rem; opacity:0.95; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:1px 6px; border:1px solid #777; border-radius:6px; background:#111; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="row">
        <div>
          <label>Velocidade do vento (1–50 m/s)</label>
          <input id="windSpeed" type="number" min="1" max="50" value="10" />
        </div>
        <div>
          <label>Direção do vento (0–359 graus)</label>
          <input id="windDir" type="number" min="0" max="359" value="0" />
        </div>
        <div>
          <button id="startBtn">Iniciar voo</button>
        </div>
      </div>
      <div class="hint">
        Controles:
        <span class="kbd">Q</span>/<span class="kbd">E</span> potência,
        <span class="kbd">A</span>/<span class="kbd">D</span> rolagem,
        <span class="kbd">W</span>/<span class="kbd">S</span> arfagem (invertido),
        <span class="kbd">Z</span>/<span class="kbd">C</span> leme,
        <span class="kbd">B</span> freio.
        No fim: <span class="kbd">S</span> novo voo, <span class="kbd">N</span> parar.
      </div>
    </div>

    <canvas id="screen" width="256" height="192" aria-label="Tela do simulador"></canvas>
  </div>

<script>
(() => {
  // Logical resolution (simulation/render layout coordinates).
  // The canvas backing store is resized to match the window and this logical
  // coordinate system is scaled to it.
  const W = 256, H = 192;
  const canvas = document.getElementById("screen");
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = true;

  const PI = Math.PI;
  const C = PI / 180;

  const SIM_HZ = 60;
  const DT = 1 / SIM_HZ;
  const MAX_CATCHUP_STEPS = 6;

  // --- Unit conversions (C++ model tuning is imperial-ish) ---
  const FT_TO_M = 0.3048;
  const M_TO_FT = 1 / FT_TO_M;
  const MPH_TO_MPS = 0.44704;
  const MPS_TO_MPH = 1 / MPH_TO_MPS;
  const MPS_TO_KMH = 3.6;
  const KMH_TO_MPH = 1 / 1.609344;
  const RPM_MAX = 3000;
  const RPM_IDLE = 50;
  // Low-speed handling helpers:
  // The core model scales control torque with airspeed; at very low speeds this can feel
  // unresponsive. We apply a small "effective airspeed" floor *only* for control authority.
  const CTRL_EFF_SPEED_MPH_MIN = 60; // ~97 km/h
  const randSigned = () => (Math.random() * 2 - 1);
  const randMul = (pct) => 1 + randSigned() * pct;
  const G_MPS2 = 9.80665;

  // --- Control effectiveness tuning (ported model was tuned for a different sim/context) ---
  // Lower values = slower response.
  // Requested tuning: elevator 2x slower, ailerons 5x slower (relative to previous values).
  const AILERON_GAIN = 0.4;   // 2.0 / 5
  const ELEVATOR_GAIN = 0.75; // 1.5 / 2
  const RUDDER_GAIN = 0.35;   // reduce yaw authority from rudder (Z/C)
  // Rendering-only scaling to make the visible pitch attitude a bit less aggressive.
  // (Does not affect the underlying flight model.)
  const PITCH_RENDER_SCALE = 0.85;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const wrap360 = (deg) => {
    deg %= 360;
    if (deg < 0) deg += 360;
    return deg;
  };
  const sgn = (x) => (x < 0 ? -1 : x > 0 ? 1 : 0);
  const rnd = (x) => Math.round(x);

  // Canvas backing-store resize (resolution independent rendering)
  let _scaleX = 1, _scaleY = 1, _pxScale = 1;
  function resizeCanvasToWindowIfNeeded() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(1, rect.width);
    const cssH = Math.max(1, rect.height);
    const newW = Math.max(1, Math.round(cssW * dpr));
    const newH = Math.max(1, Math.round(cssH * dpr));
    if (canvas.width === newW && canvas.height === newH) return;
    canvas.width = newW;
    canvas.height = newH;
    _scaleX = newW / W;
    _scaleY = newH / H;
    _pxScale = (_scaleX + _scaleY) * 0.5;
    ctx.setTransform(_scaleX, 0, 0, _scaleY, 0, 0);
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
  }
  window.addEventListener("resize", () => resizeCanvasToWindowIfNeeded());

  function clearScreen() {
    resizeCanvasToWindowIfNeeded();
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);
  }
  function _snapToDevicePixelCenterX(x) {
    // Convert to device pixels, snap to pixel center, convert back to logical coords.
    return (Math.round(x * _scaleX) + 0.5) / _scaleX;
  }
  function _snapToDevicePixelCenterY(y) {
    return (Math.round(y * _scaleY) + 0.5) / _scaleY;
  }
  function line(x1, y1, x2, y2) {
    // Keep strokes 1 device pixel wide regardless of canvas scaling.
    ctx.lineWidth = 1 / _pxScale;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
  function lineSnapped(x1, y1, x2, y2) {
    // Snap endpoints to device-pixel centers to avoid shimmering/flicker with anti-aliasing.
    x1 = _snapToDevicePixelCenterX(x1);
    x2 = _snapToDevicePixelCenterX(x2);
    y1 = _snapToDevicePixelCenterY(y1);
    y2 = _snapToDevicePixelCenterY(y2);
    line(x1, y1, x2, y2);
  }
  function dotSnapped(x, y) {
    // Draw a single device pixel at (x,y) in logical coordinates.
    const px = Math.round(x * _scaleX);
    const py = Math.round(y * _scaleY);
    ctx.fillRect(px / _scaleX, py / _scaleY, 1 / _scaleX, 1 / _scaleY);
  }
  function dotSoft(x, y) {
    // Draw ~1 device-pixel dot but do NOT snap to pixel centers (reduces moiré patterns).
    const w = 1 / _scaleX;
    const h = 1 / _scaleY;
    ctx.fillRect(x - w * 0.5, y - h * 0.5, w, h);
  }
  function dotSoftPx(x, y, pxSize) {
    // Draw a pxSize x pxSize dot in *device pixels* (converted to logical coords),
    // without snapping to pixel centers.
    const w = pxSize / _scaleX;
    const h = pxSize / _scaleY;
    ctx.fillRect(x - w * 0.5, y - h * 0.5, w, h);
  }
  function circle(cx, cy, r) {
    ctx.lineWidth = 1 / _pxScale;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
  }
  function dialBezel(cx, cy, r) {
    // Two concentric circles: outer slightly larger than inner.
    circle(cx, cy, r);
    circle(cx, cy, r + 2);
  }
  function needle(cx, cy, len, aRad) {
    const x2 = cx + len * Math.sin(aRad);
    const y2 = cy - len * Math.cos(aRad);
    line(cx, cy, x2, y2);
  }
  function textCentered(cx, y, s) {
    const w = ctx.measureText(s).width;
    ctx.fillText(s, cx - w / 2, y);
  }

  // Liang–Barsky line clipping
  function clipLineToRect(x1, y1, x2, y2, rx, ry, rw, rh) {
    let t0 = 0, t1 = 1;
    const dx = x2 - x1, dy = y2 - y1;
    function clip(p, q) {
      if (p === 0) return q >= 0;
      const r = q / p;
      if (p < 0) { if (r > t1) return false; if (r > t0) t0 = r; }
      else       { if (r < t0) return false; if (r < t1) t1 = r; }
      return true;
    }
    if (
      clip(-dx, x1 - rx) &&
      clip( dx, (rx + rw) - x1) &&
      clip(-dy, y1 - ry) &&
      clip( dy, (ry + rh) - y1)
    ) {
      const nx1 = x1 + t0 * dx, ny1 = y1 + t0 * dy;
      const nx2 = x1 + t1 * dx, ny2 = y1 + t1 * dy;
      return [nx1, ny1, nx2, ny2];
    }
    return null;
  }

  // Polygon clipping (Sutherland–Hodgman) against axis-aligned rectangle
  function clipPolygonRect(poly, xmin, xmax, ymin, ymax) {
    function clipEdge(points, insideFn, intersectFn) {
      const out = [];
      if (!points.length) return out;
      let S = points[points.length - 1];
      for (const E of points) {
        const Ein = insideFn(E);
        const Sin = insideFn(S);
        if (Ein) {
          if (!Sin) out.push(intersectFn(S, E));
          out.push(E);
        } else if (Sin) {
          out.push(intersectFn(S, E));
        }
        S = E;
      }
      return out;
    }

    function intersectX(p1, p2, x) {
      const [x1,y1] = p1, [x2,y2] = p2;
      const dx = x2 - x1;
      if (dx === 0) return [x, y1];
      const t = (x - x1) / dx;
      return [x, y1 + t * (y2 - y1)];
    }
    function intersectY(p1, p2, y) {
      const [x1,y1] = p1, [x2,y2] = p2;
      const dy = y2 - y1;
      if (dy === 0) return [x1, y];
      const t = (y - y1) / dy;
      return [x1 + t * (x2 - x1), y];
    }

    let out = poly.slice();
    out = clipEdge(out, p => p[0] >= xmin, (s,e) => intersectX(s,e,xmin));
    out = clipEdge(out, p => p[0] <= xmax, (s,e) => intersectX(s,e,xmax));
    out = clipEdge(out, p => p[1] >= ymin, (s,e) => intersectY(s,e,ymin));
    out = clipEdge(out, p => p[1] <= ymax, (s,e) => intersectY(s,e,ymax));
    return out;
  }

  function drawPolygon(poly) {
    if (!poly || poly.length < 2) return;
    for (let i = 0; i < poly.length; i++) {
      const a = poly[i];
      const b = poly[(i + 1) % poly.length];
      line(a[0], a[1], b[0], b[1]);
    }
  }

  // --- Minimal 3D camera (world meters) for the top window ---
  function v3(x, y, z) { return { x, y, z }; }
  function v3sub(a, b) { return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }; }
  function v3add(a, b) { return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }; }
  function v3mul(a, s) { return { x: a.x * s, y: a.y * s, z: a.z * s }; }
  function v3dot(a, b) { return a.x * b.x + a.y * b.y + a.z * b.z; }

  function computeCameraBasis(yawDeg, pitchNoseUpDeg, rollDeg) {
    // World axes: +X right, +Y forward, +Z up. Camera axes: +x right, +y down, +z forward.
    const psi = yawDeg * C;
    const th = pitchNoseUpDeg * C;
    const ph = rollDeg * C;

    // Start at level flight heading +Y.
    let f = v3(Math.sin(psi), Math.cos(psi), 0);
    let r = v3(Math.cos(psi), -Math.sin(psi), 0);
    let u = v3(0, 0, 1);

    // Pitch about right axis (nose up positive).
    {
      const f0 = f, u0 = u;
      f = v3add(v3mul(f0, Math.cos(th)), v3mul(u0, Math.sin(th)));
      u = v3add(v3mul(u0, Math.cos(th)), v3mul(f0, -Math.sin(th)));
    }

    // Roll about forward axis.
    const r2 = v3add(v3mul(r, Math.cos(ph)), v3mul(u, Math.sin(ph)));
    const u2 = v3add(v3mul(u, Math.cos(ph)), v3mul(r, -Math.sin(ph)));
    r = r2; u = u2;

    return { camRight: r, camDown: v3mul(u, -1), camFwd: f };
  }

  function worldToCamera(pWorld, camPos, basis) {
    const rel = v3sub(pWorld, camPos);
    return v3(
      v3dot(rel, basis.camRight),
      v3dot(rel, basis.camDown),
      v3dot(rel, basis.camFwd)
    );
  }

  function clipSegmentToNearPlane(p1, p2, nearZ) {
    // Keep z >= nearZ
    const z1 = p1.z, z2 = p2.z;
    const in1 = z1 >= nearZ, in2 = z2 >= nearZ;
    if (in1 && in2) return [p1, p2];
    if (!in1 && !in2) return null;
    const t = (nearZ - z1) / (z2 - z1);
    const pi = v3add(p1, v3mul(v3sub(p2, p1), t));
    if (!in1) return [pi, p2];
    return [p1, pi];
  }

  function clipPolygonToNearPlane(polyCam, nearZ) {
    // Sutherland–Hodgman in camera space, keep z >= nearZ
    const out = [];
    if (!polyCam || polyCam.length < 3) return out;
    let S = polyCam[polyCam.length - 1];
    const Sin = S.z >= nearZ;
    let SinFlag = Sin;
    for (const E of polyCam) {
      const EinFlag = E.z >= nearZ;
      if (EinFlag) {
        if (!SinFlag) {
          const t = (nearZ - S.z) / (E.z - S.z);
          out.push(v3add(S, v3mul(v3sub(E, S), t)));
        }
        out.push(E);
      } else if (SinFlag) {
        const t = (nearZ - S.z) / (E.z - S.z);
        out.push(v3add(S, v3mul(v3sub(E, S), t)));
      }
      S = E;
      SinFlag = EinFlag;
    }
    return out;
  }

  function projectCamToScreen(pCam, intr) {
    // Accept points exactly on the near plane (z == nearZ). Polygons/segments are
    // clipped to nearZ, and rejecting equality can cause geometry to disappear
    // at low altitude/pitch when many points land exactly on the plane.
    if (pCam.z < intr.nearZ) return null;
    const x = intr.cx + intr.f * (pCam.x / pCam.z);
    const y = intr.cy + intr.f * (pCam.y / pCam.z);
    if (!isFinite(x) || !isFinite(y)) return null;
    return [x, y];
  }

  function lineRectIntersections(A, B, Cc, xmin, xmax, ymin, ymax) {
    // Line: A*x + B*y + Cc = 0. Return up to 2 unique points on the rectangle boundary.
    const pts = [];
    const eps = 1e-9;
    function addPt(x, y) {
      if (!isFinite(x) || !isFinite(y)) return;
      if (x < xmin - 1e-6 || x > xmax + 1e-6 || y < ymin - 1e-6 || y > ymax + 1e-6) return;
      for (const p of pts) {
        if (Math.abs(p[0] - x) < 0.25 && Math.abs(p[1] - y) < 0.25) return;
      }
      pts.push([x, y]);
    }

    // x = xmin/xmax -> solve for y
    if (Math.abs(B) > eps) {
      addPt(xmin, -(A * xmin + Cc) / B);
      addPt(xmax, -(A * xmax + Cc) / B);
    }
    // y = ymin/ymax -> solve for x
    if (Math.abs(A) > eps) {
      addPt(-(B * ymin + Cc) / A, ymin);
      addPt(-(B * ymax + Cc) / A, ymax);
    }
    if (pts.length <= 2) return pts;
    // If we got more due to corner hits, keep the two farthest apart
    let best = [pts[0], pts[1]];
    let bestD = -1;
    for (let i = 0; i < pts.length; i++) {
      for (let j = i + 1; j < pts.length; j++) {
        const dx = pts[i][0] - pts[j][0];
        const dy = pts[i][1] - pts[j][1];
        const d = dx * dx + dy * dy;
        if (d > bestD) { bestD = d; best = [pts[i], pts[j]]; }
      }
    }
    return best;
  }

  // --- Game state ---
  let running = false;
  let ended = false;
  let started = false;
  let endMessage = [];

  // Landing-game coordinates (metric)
  let PX = 0, PY = 0, PZ = 0; // meters; PZ is altitude above runway plane
  let VX = 0, VY = 0, VZ = 0; // m/s (derived from flight model)
  let GX = 0, GY = 0, GZ = 0; // m/s with wind
  let AD = 0;                 // heading degrees (0..360)

  // Wind (metric, m/s)
  let WX = 0, WY = 0;

  // --- C++ flight-model state (ported) ---
  // Control surfaces (reduced indices, -15..+15)
  let aileron_pos = 0;
  let elevator_pos = 0;
  let rudder_pos = 0;
  let brake = true;

  // Engine / power
  let ignition_on = true;
  let engine_on = true;
  let throttle_pos = 0; // scaled from TC for C++ formulas
  let rpm = 0;

  // Attitude (degrees)
  let roll = 0;
  let pitch = 0;
  let yaw = 0; // degrees, mapped to AD

  // Speeds tuned like C++ (mostly mph and feet-per-loop)
  let h_speed_mph = 0;       // horizontal speed (mph)
  let v_speed_ft = 0;        // vertical displacement per loop (feet/loop)
  let delta_z_ft = 0;        // forward displacement per loop (feet/loop)
  let efAOF_rad = 0;         // effective angle of flight (radians)
  let stall = false;
  let airborne = true;

  // Rotational deltas (degrees per loop; C++ labels deg/ms but applies as deg/loop)
  const deltaVect = { dPitch: 0, dYaw: 0, dRoll: 0 };

  // User-facing throttle knob (kept for RPM dial behavior)
  let TC = 5; // 0.2..8.8

  const RT = 3, TP = 5, WR = 50; // landing thresholds: roll, pitch, runway half-width (meters)

  // Runway model used by the renderer/instruments (world meters).
  // The 3D runway drawing uses a strip starting at Y=0 (touchdown threshold)
  // extending forward (+Y). Instruments should reference the same runway geometry.
  const RUNWAY_START_Y = 0;
  const RUNWAY_LEN_M = 3000;
  const RUNWAY_END_Y = RUNWAY_START_Y + RUNWAY_LEN_M;
  const RUNWAY_REF_Y = RUNWAY_START_Y + RUNWAY_LEN_M * 0.5; // instrument reference point on runway

  const keysDown = new Set();
  let bWasDown = false;

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    // End screen choices: ignore repeats so holding a key won't restart instantly.
    // R = restart (yes), N = stop (no).
    if (ended && (k === "r" || k === "n")) {
      if (e.repeat) return;
      if (k === "r") document.getElementById("startBtn").click();
      else if (k === "n") {
        running = false;
        ended = true;
        endMessage = ["Encerrado.", "Recarregue a página para jogar novamente."];
      }
      return;
    }

    keysDown.add(k);
  });
  window.addEventListener("keyup", (e) => keysDown.delete(e.key.toLowerCase()));

  function setDemoScreenState() {
    running = false;
    ended = false;
    endMessage = [];
    PX = 0; PY = 0; PZ = 0;
    VX = 0; VY = 0; VZ = 0;
    GX = 0; GY = 0; GZ = 0;
    AD = 0;
    WX = 0; WY = 0;

    aileron_pos = 0;
    elevator_pos = 0;
    rudder_pos = 0;
    brake = true;
    ignition_on = true;
    engine_on = true;
    throttle_pos = 0;
    rpm = 0;
    roll = 0;
    pitch = 0;
    yaw = 0;
    h_speed_mph = 0;
    v_speed_ft = 0;
    delta_z_ft = 0;
    efAOF_rad = 0;
    stall = false;
    airborne = true;
    deltaVect.dPitch = deltaVect.dYaw = deltaVect.dRoll = 0;
    TC = 5;

    bWasDown = false;
    keysDown.clear();
  }

  function resetGame(windSpeed, windDir) {
    ended = false;
    endMessage = [];
    keysDown.clear();

    // Start position (metric)
    PX = 0;
    PY = -10000;
    // Add ~10% randomness to initial altitude.
    PZ = 750 * randMul(0.10);

    // Start attitude
    roll = 0;
    pitch = 0;
    // Add ~10% randomness to initial bearing (±36° around north).
    yaw = randSigned() * 36;
    AD = wrap360(yaw);

    // Start throttle / engine
    // Initialize throttle so the starting RPM is ~2000 and stable (nominal ~= rpm).
    {
      const THROTTLE_POS_MAX = 75;
      const RPM_PER_THROTTLE = (RPM_MAX - RPM_IDLE) / THROTTLE_POS_MAX;
      const RPM_START = 2000;
      throttle_pos = clamp((RPM_START - RPM_IDLE) / RPM_PER_THROTTLE, 0, THROTTLE_POS_MAX);
      TC = clamp(throttle_pos / 8.5, 0.2, 8.8);
    }
    ignition_on = true;
    engine_on = true;

    // Start speed (+/- 10% randomness).
    const START_SPEED_KMH = 200 * randMul(0.10);
    h_speed_mph = START_SPEED_KMH * KMH_TO_MPH;

    // Start rpm
    rpm = 2000;

    // Wind scaling from original BASIC: windSpeed/3
    const X0 = windSpeed / 3;
    const X1 = windDir;
    WY = X0 * Math.cos(X1 * C);
    WX = -X0 * Math.sin(X1 * C);

    // Controls reset
    aileron_pos = 0;
    elevator_pos = 0;
    rudder_pos = 0;
    brake = false;
    stall = false;
    airborne = true;
    deltaVect.dPitch = deltaVect.dYaw = deltaVect.dRoll = 0;
    v_speed_ft = 0;
    delta_z_ft = 0;
    efAOF_rad = 0;

    running = true;
  }

  function rads(deg) {
    if (deg < 0) deg += 360;
    return deg * C;
  }
  function degs(rad) {
    return rad / C;
  }

  function updateControls(dt) {
    // Throttle change is time-based. Preserve ~0.2 per tick @60Hz feel.
    const TC_RATE = 12.0;
    if (keysDown.has("q")) TC += TC_RATE * dt;
    if (keysDown.has("e")) TC -= TC_RATE * dt;
    TC = clamp(TC, 0.2, 8.8);

    // Toggle brakes (edge-triggered)
    const bDown = keysDown.has("b");
    if (bDown && !bWasDown) brake = !brake;
    bWasDown = bDown;

    // Roll: A/D
    let rollIn = 0;
    if (keysDown.has("a")) rollIn -= 1;
    if (keysDown.has("d")) rollIn += 1;

    // Pitch: W nose up, S nose down (inverted compared to the prior mapping).
    let pitchIn = 0;
    if (keysDown.has("w")) pitchIn += 1;
    if (keysDown.has("s")) pitchIn -= 1;

    // Rudder: Z/C
    let rudderIn = 0;
    if (keysDown.has("z")) rudderIn += 1;
    if (keysDown.has("c")) rudderIn -= 1;

    // Control surfaces: self-centering with a smooth first-order response.
    // The straight port that *integrates* surface position can "wind up" and
    // keep rolling/looping even after keys are released. This makes the sim
    // far more controllable while still using the C++ dynamics core.
    const AIL_TARGET = rollIn * 15;
    const ELE_TARGET = pitchIn * 15;
    // Rudder gets a smaller target deflection to keep yaw more manageable.
    const RUD_TARGET = rudderIn * 8;
    const SURF_RESP = 5.0; // 1/s (lower = slower to respond and slower to return to center)
    const alpha = 1 - Math.exp(-SURF_RESP * dt);
    aileron_pos = clamp(aileron_pos + (AIL_TARGET - aileron_pos) * alpha, -15, 15);
    elevator_pos = clamp(elevator_pos + (ELE_TARGET - elevator_pos) * alpha, -15, 15);

    rudder_pos = clamp(rudder_pos + (RUD_TARGET - rudder_pos) * alpha, -15, 15);

    // Throttle position for C++ formulas (0..~75)
    throttle_pos = clamp(TC * 8.5, 0, 75);
  }

  function calcPowerDyn(loopTimeMs) {
    if (ignition_on) {
      if (!engine_on) engine_on = true;
      // Map throttle_pos (0..75) to RPM range (idle..RPM_MAX) so throttle isn't overly strong.
      const THROTTLE_POS_MAX = 75;
      const RPM_PER_THROTTLE = (RPM_MAX - RPM_IDLE) / THROTTLE_POS_MAX;
      const nominal = RPM_IDLE + (throttle_pos * RPM_PER_THROTTLE);
      if (rpm < nominal) rpm += loopTimeMs * 0.5;
      if (rpm > nominal) rpm -= loopTimeMs * 0.5;
    } else {
      if (engine_on) engine_on = false;
      if (rpm) rpm -= (loopTimeMs / 2);
    }
    if (rpm < 0) rpm = 0;
    // Minimum running/idle RPM while ignition is on.
    if (ignition_on && rpm > 0 && rpm < RPM_IDLE) rpm = RPM_IDLE;
    if (rpm > RPM_MAX) rpm = RPM_MAX;
  }

  function calcFlightDyn(loopTimeMs) {
    // Port of AirCraft::CalcFlightDyn with the same tuning assumptions.
    const STALL_SPEED_MPH = 80 * KMH_TO_MPH;   // stall threshold at 80 km/h
    // Tune: rpm hard-caps at 3000, so set this so max rpm yields ~400 km/h (~248.5 mph).
    const RPM_TO_MPH = RPM_MAX / (400 * KMH_TO_MPH);

    let iSpeed = rpm / RPM_TO_MPH;
    iSpeed += (pitch * 1.5);

    let hAccel = ((rpm * (iSpeed - h_speed_mph)) / 10000);
    hAccel /= 1000;
    hAccel *= loopTimeMs;

    // Brake acts as:
    // - Strong ground brake when on wheels
    // - Mild airbrake drag when airborne (reduces airspeed too, but less than on ground)
    const BRAKE_GROUND_DECEL_MPH = 1.0;
    const AIRBRAKE_DECEL_MPH = 0.25;

    if (brake && !airborne) {
      h_speed_mph = Math.max(0, h_speed_mph - BRAKE_GROUND_DECEL_MPH);
    } else {
      h_speed_mph += hAccel;
      if (brake && airborne) h_speed_mph = Math.max(0, h_speed_mph - AIRBRAKE_DECEL_MPH);
    }

    // Lift curve
    let lSpeed = (h_speed_mph / STALL_SPEED_MPH) - 1;
    if (lSpeed > 1) lSpeed = 1;
    let lVeloc = degs(Math.atan(lSpeed));
    lVeloc += 45;
    lVeloc /= 5.29;
    lVeloc *= (-(pitch * 0.157) + 1);
    lVeloc /= 1000;
    lVeloc *= loopTimeMs;

    // Gravity term (C++ uses -16 ft/sec)
    const GRAV_C_FTPS = -16.0;
    const gVeloc = loopTimeMs * (GRAV_C_FTPS / 1000);
    v_speed_ft = gVeloc + lVeloc;
    if ((!airborne) && (v_speed_ft < 0)) v_speed_ft = 0;

    // Forward displacement from mph
    delta_z_ft = h_speed_mph * 5280;
    delta_z_ft /= 3600000;
    delta_z_ft *= loopTimeMs;

    // Effective angle of flight
    if (delta_z_ft) efAOF_rad = -(Math.atan(v_speed_ft / delta_z_ft));
    else efAOF_rad = -(Math.atan(v_speed_ft));

    const AOA = degs(efAOF_rad);

    // Stall logic (ported)
    if (((pitch < AOA) && (AOA < 0)) && (h_speed_mph < STALL_SPEED_MPH)) {
      if ((pitch - AOA) < -20) stall = true;
    }
    if (stall) {
      if (pitch > 30) stall = false;
      else pitch++;
    }
  }

  function inertialDamp() {
    // At low speeds, the speed-scaled control torques are small; overly aggressive damping
    // can zero out the resulting small angular deltas and make controls feel "dead".
    // Reduce damping a bit at low speed while airborne to preserve responsiveness.
    const eff = airborne ? clamp(h_speed_mph / CTRL_EFF_SPEED_MPH_MIN, 0.35, 1.0) : 1.0;
    const dampDiv = 10 / eff; // larger => less damping
    const eps = airborne ? 0.003 : 0.01;
    if (deltaVect.dPitch) {
      deltaVect.dPitch -= deltaVect.dPitch / dampDiv;
      if (((deltaVect.dPitch > 0) && (deltaVect.dPitch < eps)) ||
          ((deltaVect.dPitch < 0) && (deltaVect.dPitch > -eps))) {
        deltaVect.dPitch = 0;
      }
    }
    if (deltaVect.dYaw) {
      deltaVect.dYaw -= deltaVect.dYaw / dampDiv;
      if (((deltaVect.dYaw > 0) && (deltaVect.dYaw < eps)) ||
          ((deltaVect.dYaw < 0) && (deltaVect.dYaw > -eps))) {
        deltaVect.dYaw = 0;
      }
    }
    if (deltaVect.dRoll) {
      deltaVect.dRoll -= deltaVect.dRoll / dampDiv;
      if (((deltaVect.dRoll > 0) && (deltaVect.dRoll < eps)) ||
          ((deltaVect.dRoll < 0) && (deltaVect.dRoll > -eps))) {
        deltaVect.dRoll = 0;
      }
    }
  }

  function calcTurnRate() {
    let torque = 0.0;
    if ((roll > 0) && (roll <= 90)) torque = (roll * 0.00050);
    else if ((roll < 0) && (roll >= -90)) torque = (roll * 0.00050);
    return torque;
  }

  function calcROC(loopTimeMs) {
    const ctrlSpeedMph = airborne ? Math.max(h_speed_mph, CTRL_EFF_SPEED_MPH_MIN) : h_speed_mph;
    let torque;
    if (airborne) {
      if (aileron_pos !== 0) {
        torque = ((ctrlSpeedMph * aileron_pos) / 10000);
        if (deltaVect.dRoll !== (torque * loopTimeMs)) deltaVect.dRoll += torque * AILERON_GAIN;
      }
    }
    if (elevator_pos !== 0) {
      torque = ((ctrlSpeedMph * elevator_pos) / 10000);
      if ((!airborne) && (torque > 0)) torque = 0;
      if (deltaVect.dPitch !== (torque * loopTimeMs)) deltaVect.dPitch += torque * ELEVATOR_GAIN;
    }
    if (ctrlSpeedMph) {
      torque = 0.0;
      if (rudder_pos !== 0) torque = -((ctrlSpeedMph * rudder_pos) / 10000) * RUDDER_GAIN;
      torque += calcTurnRate();
      if (deltaVect.dYaw !== (torque * loopTimeMs)) deltaVect.dYaw += torque * 1.5;
    }

    // Hard caps on angular deltas (deg per simulation step) to prevent runaway rates
    // in the discrete-time port.
    deltaVect.dRoll  = clamp(deltaVect.dRoll,  -1.2, 1.2);
    deltaVect.dPitch = clamp(deltaVect.dPitch, -1.0, 1.0);
    deltaVect.dYaw   = clamp(deltaVect.dYaw,   -1.2, 1.2);
  }

  function applyRots() {
    roll += deltaVect.dRoll;
    yaw += deltaVect.dYaw;
    pitch += (deltaVect.dPitch * Math.cos(rads(roll)));
    yaw += -(deltaVect.dPitch * Math.sin(rads(roll)));

    // bounds roll/yaw to [-180..180]
    if (roll > 180) roll = -180 + (roll - 180);
    else if (roll < -180) roll = 180 + (roll + 180);
    if (yaw > 180) yaw = -180 + (yaw - 180);
    else if (yaw < -180) yaw = 180 + (yaw + 180);

    // special case pitch past vertical
    if ((pitch > 90) || (pitch < -90)) {
      if (roll >= 0) roll -= 180;
      else roll += 180;
      if (yaw >= 0) yaw -= 180;
      else yaw += 180;
      if (pitch > 0) pitch = (180 - pitch);
      else pitch = (-180 - pitch);
    }

    // damp close to zero (avoid aggressive "auto-level" feel at low speed)
    if ((pitch > -0.2) && (pitch < 0.2)) pitch = 0;
    if ((roll > -0.2) && (roll < 0.2)) roll = 0;
    if ((yaw > -0.2) && (yaw < 0.2)) yaw = 0;
  }

  function integratePosition(loopTimeMs) {
    // Port the simplified rotation path in RunFModel (roll rotation omitted in v2.1).
    const tmpZ = delta_z_ft;

    // Rotate in X by effective angle of flight
    const newY_ft = -(tmpZ * Math.sin(efAOF_rad));
    const newZ_ft = (tmpZ * Math.cos(efAOF_rad));

    // Rotate in Y by yaw
    const yawRad = rads(yaw);
    const dX_ft = (newZ_ft * Math.sin(yawRad));
    const dFwd_ft = (newZ_ft * Math.cos(yawRad));

    // Apply to metric positions.
    // Convention used everywhere else in this HTML port (HUD/camera):
    // 0° = +Y, 90° = +X, 180° = -Y, 270° = -X.
    // So positive yaw increases +X.
    PX += dX_ft * FT_TO_M;
    PY += dFwd_ft * FT_TO_M;
    PZ += newY_ft * FT_TO_M;

    // Update heading for UI
    AD = wrap360(yaw < 0 ? yaw + 360 : yaw);

    // Airborne flag (simple): becomes airborne once altitude > 0
    if ((!airborne) && (PZ > 0)) airborne = true;
  }

  function stepPhysics(dt) {
    const loopTimeMs = Math.max(1, dt * 1000);

    // C++ ordering: power/flight dynamics, damping, ROC, apply rotations, integrate.
    calcPowerDyn(loopTimeMs);
    calcFlightDyn(loopTimeMs);
    inertialDamp();
    calcROC(loopTimeMs);
    applyRots();
    integratePosition(loopTimeMs);

    // Derive velocities for wind + instruments from current state
    const speedMps = Math.max(0, h_speed_mph * MPH_TO_MPS);
    const ra = AD * C;
    VX = speedMps * Math.sin(ra);
    VY = speedMps * Math.cos(ra);
    VZ = v_speed_ft * FT_TO_M / dt; // ft/loop -> m/s (approx; avoids re-deriving from efAOF)

    GX = VX + WX;
    GY = VY + WY;
    GZ = VZ;

    // Integrate wind drift using metric velocities (keeps old UI behavior).
    // Note: primary position integration already happened via C++ model (still-air).
    PX += WX * dt;
    PY += WY * dt;

    // Ground contact => finish
    if (PZ <= 0) {
      PZ = 0;
      finishLanding();
    }
  }

  function finishLanding() {
    keysDown.clear();
    running = false;
    ended = true;

    // Distance to runway reference point (meters). Keeps DRIFT and DISTANCE consistent:
    // DISTANCE is always >= |DRIFT|.
    const dxr = PX;
    const dyr = PY - RUNWAY_REF_Y;
    const dist = Math.sqrt(dxr*dxr + dyr*dyr);
    const vvMps = Math.max(0, h_speed_mph * MPH_TO_MPS);
    const vvKmh = vvMps * MPS_TO_KMH;
    const onRunway =
      (Math.abs(PX) <= WR) &&
      (PY >= RUNWAY_START_Y) &&
      (PY <= RUNWAY_END_Y);

    // Reuse original scoring thresholds (tuned for the landing mini-game).
    if (Math.abs(roll) > RT || pitch > TP || pitch < 0 || vvMps > 80) {
      endMessage = [
        "LAMENTAMOS INFORMAR QUE O VOO PJ26 SOFREU UM GRAVE ACIDENTE.",
        "NAO HA SOBREVIVENTES."
      ];
    } else if (!onRunway) {
      if (vvMps < 40) endMessage = ["VOCE POUSOU FORA DA PISTA.", "COMO SUA VELOCIDADE ERA BAIXA,",
        " QUASE NADA ACONTECEU."];
      else if (vvMps < 80) endMessage = ["VOCE POUSOU FORA DA PISTA.", "ENTRE MORTOS E FERIDOS,",
        " SALVARAM-SE TODOS."];
      else endMessage = ["VOCE POUSOU FORA DA PISTA.", "NINGUEM SOBREVIVE A UM POUSO",
        " NESTA VELOCIDADE."];
    } else {
      endMessage = ["PARABENS!", "ATERRISSAGEM BEM SUCEDIDA."];
    }

    endMessage.push("");
    endMessage.push("VALORES RELATIVOS AO POUSO:");
    endMessage.push(`VELOCIDADE DO AR = ${Math.floor(vvKmh)} KM/H`);
    endMessage.push(`DISTANCIA        = ${Math.floor(dist)} M`);
    endMessage.push(`INCLINACAO FRONTAL= ${Math.floor(pitch)}`);
    endMessage.push(`INCLINACAO LATERAL= ${Math.floor(roll)}`);
    endMessage.push(`ROTACAO DO MOTOR  = ${Math.floor(rpm)} RPM`);
    endMessage.push(`DESVIO DA PISTA   = ${Math.floor(PX)} M`);
    endMessage.push(`DIRECAO           = ${Math.floor(AD)} GRAUS`);
    endMessage.push("");
    endMessage.push("REINICIAR? (R/N)");
  }

  function computeRunwayBearingRB() {
    if (!started) return 0;
    // Bearing from aircraft to a runway reference point on the drawn runway strip.
    // Heading convention: 0° = +Y, clockwise positive, as used by the HUD.
    const dx = 0 - PX;
    const dy = RUNWAY_REF_Y - PY;
    if (dx === 0 && dy === 0) return 0;
    const RB = Math.atan2(dx, dy) / C;
    return wrap360(RB);
  }

  // --- TOP WINDOW ---
  function drawWindowAndRunway() {
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;

    line(10, 0, 245, 0);
    line(245, 0, 245, 80);
    line(245, 80, 10, 80);
    line(10, 80, 10, 0);

    const xmin = 16, xmax = 239, ymin = 1, ymax = 79;
    const vw = (xmax - xmin);
    const vh = (ymax - ymin);
    const intr = {
      cx: (xmin + xmax) * 0.5,
      cy: (ymin + ymax) * 0.5,
      f: (vw * 0.5) / Math.tan(60 * C * 0.5),
      nearZ: 1.0
    };

    // Camera pose: use aircraft position and attitude.
    // Model convention: pitch increases when pitching down, so invert to get "nose up".
    const camPos = v3(PX, PY, PZ);
    const basis = computeCameraBasis(AD, -pitch * PITCH_RENDER_SCALE, roll);

    // Near plane: keep small. A large nearZ (like 1m) can slice the runway when low,
    // producing unstable polygons. We keep it small but non-zero to avoid blowups.
    intr.nearZ = Math.max(0.05, Math.min(0.2, camPos.z * 0.02));

    // Camera-correct horizon line: a*(X-cx)+b*(Y-cy)+c*f = 0
    // Keep coefficients so the ground-grid can extend up to the horizon.
    let horizonA = 0, horizonB = 0, horizonC = 0;
    {
      const worldUp = v3(0, 0, 1);
      const a = v3dot(basis.camRight, worldUp);
      const b = v3dot(basis.camDown, worldUp);
      const c = v3dot(basis.camFwd, worldUp);
      const A = a;
      const B = b;
      const Cc = c * intr.f - a * intr.cx - b * intr.cy;
      horizonA = A; horizonB = B; horizonC = Cc;
      const pts = lineRectIntersections(A, B, Cc, xmin, xmax, ymin, ymax);
      if (pts.length === 2) line(pts[0][0], pts[0][1], pts[1][0], pts[1][1]);
    }

    if (!started) return;

    // --- Ground grid as dots at intersections (500m spacing) on Z=0 ---
    ctx.save();
    ctx.fillStyle = "#9aa";
    ctx.globalAlpha = 0.55;
    const GRID = 500;

    function screenRayDirWorld(x, y) {
      // Camera ray through pixel (x,y). Camera coordinates: z forward, y down.
      const dx = (x - intr.cx) / intr.f;
      const dy = (y - intr.cy) / intr.f;
      // World dir = camRight*dx + camDown*dy + camFwd*1
      return v3add(v3add(v3mul(basis.camRight, dx), v3mul(basis.camDown, dy)), basis.camFwd);
    }

    function intersectRayWithGroundZ0(dirWorld) {
      // Ray: camPos + t*dirWorld, ground plane z=0.
      const eps = 1e-9;
      if (dirWorld.z >= -eps) return null; // not pointing toward ground
      const t = (0 - camPos.z) / dirWorld.z;
      if (!isFinite(t) || t <= 0) return null;
      return v3add(camPos, v3mul(dirWorld, t));
    }

    // Find a y coordinate just below the horizon (at screen center).
    let yH = null;
    if (Math.abs(horizonB) > 1e-9) {
      yH = -(horizonA * intr.cx + horizonC) / horizonB;
    }
    const ySample = clamp((yH == null ? intr.cy : (yH + 1)), ymin, ymax);

    // Estimate "visible-to-horizon" ground distance by intersecting a few rays
    // just below the horizon and at the bottom of the viewport.
    const samplePts = [
      [xmin, ySample],
      [intr.cx, ySample],
      [xmax, ySample],
      [xmin, ymax],
      [intr.cx, ymax],
      [xmax, ymax],
    ];
    let farDist = 0;
    const groundHits = [];
    for (const [sx, sy] of samplePts) {
      const hit = intersectRayWithGroundZ0(screenRayDirWorld(sx, sy));
      if (!hit) continue;
      groundHits.push(hit);
      const d = Math.hypot(hit.x - PX, hit.y - PY);
      if (isFinite(d) && d > farDist) farDist = d;
    }
    // Safety margins & caps (avoid huge line counts while still reaching the horizon visually).
    farDist = Math.min(Math.max(farDist * 1.15, 3000), 250000);

    // Also ensure the grid spans at least twice the distance to the runway (origin).
    const distToRunway = Math.hypot(PX, PY);
    const RANGE = Math.max(farDist, 2 * distToRunway);

    // Prefer bounding box of actually visible ground hits to keep point count reasonable.
    let minGX = PX - RANGE, maxGX = PX + RANGE, minGY = PY - RANGE, maxGY = PY + RANGE;
    if (groundHits.length >= 2) {
      minGX = Math.min(...groundHits.map(p => p.x));
      maxGX = Math.max(...groundHits.map(p => p.x));
      minGY = Math.min(...groundHits.map(p => p.y));
      maxGY = Math.max(...groundHits.map(p => p.y));
      // Expand a bit so we don't get holes at the edges due to rounding/clipping.
      minGX -= GRID; maxGX += GRID;
      minGY -= GRID; maxGY += GRID;
    }
    // Always include a local region around the aircraft so dots appear close-by
    // and to the sides, regardless of the far/horizon sampling.
    const LOCAL_X = 4000;
    const LOCAL_Y_BACK = 1000;
    const LOCAL_Y_FWD = 8000;
    minGX = Math.min(minGX, PX - LOCAL_X);
    maxGX = Math.max(maxGX, PX + LOCAL_X);
    minGY = Math.min(minGY, PY - LOCAL_Y_BACK);
    maxGY = Math.max(maxGY, PY + LOCAL_Y_FWD);

    const x0 = Math.floor(minGX / GRID) * GRID;
    const x1 = Math.ceil(maxGX / GRID) * GRID;
    const y0 = Math.floor(minGY / GRID) * GRID;
    const y1 = Math.ceil(maxGY / GRID) * GRID;

    function drawWorldDot(wx, wy) {
      const pc = worldToCamera(v3(wx, wy, 0), camPos, basis);
      if (pc.z < intr.nearZ) return;
      const s = projectCamToScreen(pc, intr);
      if (!s) return;
      if (s[0] < xmin || s[0] > xmax || s[1] < ymin || s[1] > ymax) return;
      dotSoft(s[0], s[1]);
    }

    // Draw a projected world-space segment (used for runway centerline dashes).
    function drawWorldSegment(pw1, pw2) {
      let p1c = worldToCamera(pw1, camPos, basis);
      let p2c = worldToCamera(pw2, camPos, basis);
      const clipped = clipSegmentToNearPlane(p1c, p2c, intr.nearZ);
      if (!clipped) return;
      p1c = clipped[0]; p2c = clipped[1];
      const s1 = projectCamToScreen(p1c, intr);
      const s2 = projectCamToScreen(p2c, intr);
      if (!s1 || !s2) return;
      const seg = clipLineToRect(s1[0], s1[1], s2[0], s2[1], xmin, ymin, vw, vh);
      if (seg) lineSnapped(seg[0], seg[1], seg[2], seg[3]);
    }

    // Budget dots per frame to avoid huge loops at high altitude / far horizon.
    const nx = Math.max(1, Math.floor((x1 - x0) / GRID) + 1);
    const ny = Math.max(1, Math.floor((y1 - y0) / GRID) + 1);
    // Higher target => denser dots (less skipping).
    const targetDots = 80000;
    const stride = Math.max(1, Math.ceil(Math.sqrt((nx * ny) / targetDots)));
    const step = GRID * stride;

    // Draw a dense local patch first (no skipping), so dots show up near the aircraft.
    const lx0 = Math.floor((PX - LOCAL_X) / GRID) * GRID;
    const lx1 = Math.ceil((PX + LOCAL_X) / GRID) * GRID;
    const ly0 = Math.floor((PY - LOCAL_Y_BACK) / GRID) * GRID;
    const ly1 = Math.ceil((PY + LOCAL_Y_FWD) / GRID) * GRID;
    for (let y = ly0; y <= ly1; y += GRID) {
      for (let x = lx0; x <= lx1; x += GRID) {
        drawWorldDot(x, y);
      }
    }

    // Then draw the far/horizon region with a stride (skipping) for performance.
    for (let y = y0; y <= y1; y += step) {
      for (let x = x0; x <= x1; x += step) {
        drawWorldDot(x, y);
      }
    }
    ctx.restore();

    // --- Runway as a true world rectangle on Z=0 ---
    // The landing game measures distance to the runway touchdown point at (0,0).
    // To keep the runway stable on approach (PY starts negative), define the runway
    // starting at Y=0 and extending forward (+Y), rather than centered at the origin.
    ctx.strokeStyle = "#fff";
    // (RUNWAY_START_Y / RUNWAY_END_Y are defined above)
    const rw = WR;
    const runwayWorld = [
      v3(-rw, RUNWAY_START_Y, 0),
      v3( rw, RUNWAY_START_Y, 0),
      v3( rw, RUNWAY_END_Y, 0),
      v3(-rw, RUNWAY_END_Y, 0),
    ];

    const runwayCam = runwayWorld.map(p => worldToCamera(p, camPos, basis));
    const runwayCamClipped = clipPolygonToNearPlane(runwayCam, intr.nearZ);
    if (runwayCamClipped.length >= 3) {
      const runwayScr = runwayCamClipped.map(p => projectCamToScreen(p, intr));
      // If any vertex failed projection (should be rare after near-plane clipping),
      // bail out rather than drawing a malformed polygon that can flicker.
      if (runwayScr.some(p => !p)) return;
      const runwayPoly = clipPolygonRect(runwayScr, xmin, xmax, ymin, ymax);
      if (runwayPoly.length >= 3) {
        // Mask the grid inside the runway by filling with background color.
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.moveTo(runwayPoly[0][0], runwayPoly[0][1]);
        for (let i = 1; i < runwayPoly.length; i++) ctx.lineTo(runwayPoly[i][0], runwayPoly[i][1]);
        ctx.closePath();
        ctx.fill();

        // Add dense dots on the runway surface so it stays readable up close.
        // (World-space lattice projected into screen space.)
        ctx.save();
        ctx.fillStyle = "#cfcfcf";
        ctx.globalAlpha = 0.85;
        const RUNWAY_DOT_STEP_X = 10; // meters across runway width
        const RUNWAY_DOT_STEP_Y = 20; // meters along runway length
        const RUNWAY_DOT_PX = 2;      // device pixels
        function drawRunwayDot(wx, wy) {
          const pc = worldToCamera(v3(wx, wy, 0), camPos, basis);
          if (pc.z < intr.nearZ) return;
          const s = projectCamToScreen(pc, intr);
          if (!s) return;
          if (s[0] < xmin || s[0] > xmax || s[1] < ymin || s[1] > ymax) return;
          dotSoftPx(s[0], s[1], RUNWAY_DOT_PX);
        }
        for (let yy = RUNWAY_START_Y; yy <= RUNWAY_END_Y; yy += RUNWAY_DOT_STEP_Y) {
          for (let xx = -rw; xx <= rw; xx += RUNWAY_DOT_STEP_X) {
            drawRunwayDot(xx, yy);
          }
        }
        ctx.restore();

        // Outline runway.
        ctx.strokeStyle = "#fff";
        drawPolygon(runwayPoly);

        // Centerline dashes (world space along runway center x=0)
        const dashStep = 100;
        const dashLen = 40;
        for (let yy = RUNWAY_START_Y; yy < RUNWAY_END_Y; yy += dashStep) {
          const a = v3(0, yy, 0);
          const b = v3(0, Math.min(RUNWAY_END_Y, yy + dashLen), 0);
          drawWorldSegment(a, b);
        }
      }
    }
  }

  // --- INSTRUMENTS ---
  function drawInstrumentsAndHUD() {
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;
    ctx.fillStyle = "#fff";

    const yDial = 120; // moved 20px up
    const dialR = 16; // match TURN coordinator diameter
    const cxAirspeed = 28;
    const cxHorizon  = 76;
    const cxAltitude = 124;
    const cxVario    = 172;
    const cxRpm      = 220;

    const dials = [
      { cx: cxAirspeed, top: "AIRSPEED KM/H",  bot: ""  },
      { cx: cxHorizon,  top: "HORIZ",     bot: ""   },
      { cx: cxAltitude, top: "ALTITUDE",  bot: ""    },
      { cx: cxVario,    top: "VARIO M/S",     bot: ""         },
      { cx: cxRpm,      top: "RPM",       bot: ""     },
    ];

    for (const d of dials) dialBezel(d.cx, yDial, dialR);
    for (const d of dials) {
      for (let k = 0; k < 10; k++) {
        const a = k * PI / 5;
        line(d.cx + (dialR - 1) * Math.sin(a), yDial - (dialR - 1) * Math.cos(a),
             d.cx + (dialR - 3) * Math.sin(a), yDial - (dialR - 3) * Math.cos(a));
      }
    }

    const yTopLabel  = 90;  // moved with dials
    const yDialValue = 100;  // moved with dials
    // Two-line bottom label area: label, unit, value.
    const yBotLabel  = 158;
    const yBotUnit   = 166;
    const yBotValue  = 186;

    // Keep text comfortably away from the analog dials.
    // (Especially important now that some labels include units.)
    const FONT_LABEL = "7px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const FONT_VALUE = "8px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const FONT_UNIT  = "6px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

    ctx.font = FONT_LABEL;
    for (const d of dials) {
      textCentered(d.cx, yTopLabel, d.top);
      textCentered(d.cx, yBotLabel, d.bot);
    }
    // (Bottom labels/units for RUNWAY/DRIFT/DIST were replaced by a compact text block.)

    // Heading indicator (compass rose) in the AIRSPEED column bottom area.
    // Driven by current direction/heading value (AD). Keep minimalist and keep the digital value.
    {
      const cx = cxAirspeed;
      // Move it up a bit (no BEARING label anymore) and match the other dial sizes.
      const cy = yBotLabel + 4;
      const r = dialR;

      dialBezel(cx, cy, r);

      // Rotating compass card: rotate opposite to aircraft heading so the top shows current direction.
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(-AD * C);

      // Tick marks: minor every 30°, major at cardinals.
      for (let deg = 0; deg < 360; deg += 30) {
        const a = deg * C;
        const isMajor = (deg % 90) === 0;
        const r1 = r - (isMajor ? 1 : 2);
        const r2 = r;
        line(r1 * Math.sin(a), -r1 * Math.cos(a), r2 * Math.sin(a), -r2 * Math.cos(a));
      }

      // Cardinal letters.
      ctx.font = FONT_UNIT;
      const card = [
        ["N", 0],
        ["E", 90],
        ["S", 180],
        ["W", 270],
      ];
      for (const [ch, deg] of card) {
        const a = deg * C;
        const tx = (r - 4) * Math.sin(a);
        const ty = -(r - 4) * Math.cos(a) + 2; // baseline tweak
        textCentered(tx, ty, ch);
      }
      ctx.restore();

      // Fixed reference (aircraft): simplified airplane.
      const w = r * 0.55;
      const h = r * 0.35;
      // wings
      line(cx - w, cy, cx + w, cy);
      // fuselage
      line(cx, cy - h, cx, cy + h);
      // tail
      line(cx - r * 0.18, cy + h * 0.5, cx + r * 0.18, cy + h * 0.5);
    }

    const RB = started ? computeRunwayBearingRB() : 0;
    // Distance to runway reference point (meters)
    const dist = started ? Math.sqrt(PX*PX + (PY - RUNWAY_REF_Y)*(PY - RUNWAY_REF_Y)) : 0;
    const driftM = started ? PX : 0;

    // Compact nav/status readout in the space freed by moving TURN away from VARIO:
    // label on the left, value aligned to the right.
    {
      const xLabel = cxVario - 48;
      const xValue = cxVario + 44;
      const y0 = 150;
      const dy = 12;
      ctx.font = FONT_LABEL;
      ctx.fillText("RUNAWAY DEG", xLabel, y0);
      ctx.fillText("DRIFT (M)",   xLabel, y0 + dy);
      ctx.fillText("DIST (M)",    xLabel, y0 + dy * 2);

      ctx.font = FONT_VALUE;
      // Right-align values by measuring width.
      const v1 = `${Math.floor(RB)}`;
      const v2 = `${Math.floor(driftM)}`;
      const v3 = `${Math.floor(dist)}`;
      ctx.fillText(v1, xValue - ctx.measureText(v1).width, y0);
      ctx.fillText(v2, xValue - ctx.measureText(v2).width, y0 + dy);
      ctx.fillText(v3, xValue - ctx.measureText(v3).width, y0 + dy * 2);
    }

    const vvMps = Math.max(0, h_speed_mph * MPH_TO_MPS);
    const vvKmh = vvMps * MPS_TO_KMH;
    const vsMps = started ? (v_speed_ft * FT_TO_M / DT) : 0; // m/s (vertical)
    const VARIO_DIAL_MAX_MPS = 20.0; // analog scale only: -20..+20 m/s
    const vsNeedleMps = clamp(vsMps, -VARIO_DIAL_MAX_MPS, VARIO_DIAL_MAX_MPS);

    ctx.font = FONT_VALUE;
    textCentered(cxAirspeed, yDialValue, `${Math.floor(vvKmh)}`);
    textCentered(cxAltitude, yDialValue, `${Math.floor(PZ)}`);
    {
      const v = Math.round(vsMps);
      const s = v > 0 ? `+${v}` : `${v}`;
      textCentered(cxVario, yDialValue, s);
    }
    textCentered(cxRpm,      yDialValue, `${Math.floor(rpm)}`);

    // Airspeed dial: 0..400 km/h maps to 0..2π.
    const AIRSPEED_MAX_KMH = 400;
    needle(cxAirspeed, yDial, 14, clamp(vvKmh, 0, AIRSPEED_MAX_KMH) * 2 * PI / AIRSPEED_MAX_KMH);

    // Horizon dial
    {
      const cx = cxHorizon, cy = yDial;
      const r = dialR - 4;
      const theta = -roll * 2 * C;
      const dx = Math.cos(theta), dy = Math.sin(theta);
      const uiPitch = -pitch * PITCH_RENDER_SCALE;
      const x0 = cx, y0 = cy + uiPitch;

      const fx = x0 - cx, fy = y0 - cy;
      const b = 2 * (fx * dx + fy * dy);
      const cc = (fx * fx + fy * fy) - r * r;
      const disc = b * b - 4 * cc;
      if (disc >= 0) {
        const s = Math.sqrt(disc);
        const t1 = (-b - s) / 2;
        const t2 = (-b + s) / 2;
        line(x0 + t1 * dx, y0 + t1 * dy, x0 + t2 * dx, y0 + t2 * dy);
      }

      let x = cx - 14, y = yDial;
      const segs = [[9,0],[5,5],[5,-5],[9,0]];
      for (const [sx, sy] of segs) {
        line(x, y, x + sx, y + sy);
        x += sx; y += sy;
      }
    }

    // Altitude needles (as in original)
    const TN = started ? (PZ / 1000) : 0;
    const UN = started ? (PZ - 1000 * Math.floor(TN)) : 0;
    needle(cxAltitude, yDial, 9,  TN * PI / 5);
    needle(cxAltitude, yDial, 14, UN * PI / 500);

    // Variometer (vertical speed indicator)
    {
      const cx = cxVario, cy = yDial;
      const r = dialR - 3;

      // Face text (keep simple; units match sim: m/s).
      ctx.font = "7px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      //textCentered(cx, cy - 3, "VERTICAL SPEED");
      // textCentered(cx, cy + 9, "M/S");
      // ctx.font = "8px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      // ctx.fillText("UP", cx - r + 2, cy - 2);
      // ctx.fillText("DN", cx - r + 2, cy + 10);

      // Needle: 0 points left. Positive climbs rotate over the top; negative over the bottom.
      const frac = clamp(Math.abs(vsNeedleMps) / VARIO_DIAL_MAX_MPS, 0, 1);
      const base = -PI / 2;
      const ang = vsNeedleMps >= 0 ? (base + frac * PI) : (base - frac * PI);
      ctx.font = FONT_VALUE;
      needle(cx, cy, 14, ang);
    }

    // Turn coordinator (minimalist): below VARIO.
    {
      // Move below the artificial horizon.
      const cx = cxHorizon;
      // Match the heading indicator vertical position.
      const cy = yBotLabel + 4;
      const r = 16;
      const PLANE_SCALE = 0.8; // overall airplane scale
      const WING_SCALE = 0.8;  // decrease by 20% the width (span) of the angle display

      dialBezel(cx, cy, r);

      // Reference marks (L/R standard rate).
      const m = r - 2;
      line(cx - m, cy, cx - m + 5, cy);
      line(cx + m, cy, cx + m - 5, cy);

      // Compute yaw rate (deg/s) from per-step delta.
      const yawRateDps = deltaVect.dYaw * SIM_HZ;

      // Standard rate turn (2 min) is ~3 deg/s.
      const stdRateDps = 3.0;
      const bankNeedleDeg = clamp(yawRateDps / stdRateDps, -1, 1) * 25;
      const bankNeedleRad = bankNeedleDeg * C;

      // Draw "airplane": wings + small fuselage. Rotate by turn indication.
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(bankNeedleRad);
      // wings
      line(-r * 0.85 * PLANE_SCALE * WING_SCALE, 0, r * 0.85 * PLANE_SCALE * WING_SCALE, 0);
      // fuselage
      line(0, -r * 0.15 * PLANE_SCALE, 0, r * 0.35 * PLANE_SCALE);
      // tail
      line(-r * 0.20 * PLANE_SCALE, r * 0.20 * PLANE_SCALE, r * 0.20 * PLANE_SCALE, r * 0.20 * PLANE_SCALE);
      ctx.restore();

      // Slip/skid "ball" (approx):
      // Compare actual yaw rate to coordinated-turn yaw rate from bank and speed.
      const speedMps = Math.max(1, h_speed_mph * MPH_TO_MPS);
      const bankRad = roll * C;
      const expectedYawDps = (G_MPS2 * Math.tan(bankRad) / speedMps) * (180 / PI);
      const slipDps = yawRateDps - expectedYawDps;

      // Ball track at bottom of dial.
      const trackY = cy + r * 0.55;
      const trackHalf = r * 0.55;
      // Center marks.
      line(cx - r * 0.10, trackY - 3, cx - r * 0.10, trackY + 3);
      line(cx + r * 0.10, trackY - 3, cx + r * 0.10, trackY + 3);

      const ballX = cx + clamp(slipDps / 3.0, -1, 1) * trackHalf;
      ctx.beginPath();
      ctx.arc(ballX, trackY, 3 * 0.8 * 0.5, 0, 2 * PI);
      ctx.fill();
    }

    // RPM needle (scaled to 0..~9000 mapped to 0..5*PI)
    // RPM needle: RPM_MAX maps to full scale.
    needle(cxRpm, yDial, 14, clamp(rpm / (RPM_MAX / 5), 0, 5) * PI / 5);

    ctx.font = FONT_VALUE;
    textCentered(cxAirspeed, yBotValue, `${Math.floor(started ? AD : 0)}`);
  }

  function drawEndScreen() {
    ctx.fillStyle = "rgba(0,0,0,0.92)";
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = "#fff";
    ctx.font = "10px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    let y = 18;
    for (const s of endMessage) {
      if (s === "") { y += 6; continue; }
      ctx.fillText(s, 10, y);
      y += 12;
      if (y > H - 10) break;
    }
  }

  function render() {
    clearScreen();
    ctx.strokeStyle = "#fff";
    ctx.fillStyle = "#fff";
    drawWindowAndRunway();
    drawInstrumentsAndHUD();
    if (ended) drawEndScreen();
  }

  let last = performance.now();
  let acc = 0;

  function loop(now) {
    const dtReal = (now - last) / 1000;
    last = now;
    acc += Math.min(dtReal, 0.25);

    let steps = 0;
    while (acc >= DT && steps < MAX_CATCHUP_STEPS) {
      if (running && !ended) {
        updateControls(DT);
        stepPhysics(DT);
      }
      acc -= DT;
      steps++;
    }

    render();
    requestAnimationFrame(loop);
  }

  document.getElementById("startBtn").addEventListener("click", () => {
    const ws = clamp(parseFloat(document.getElementById("windSpeed").value || "10"), 1, 50);
    const wd = wrap360(parseFloat(document.getElementById("windDir").value || "0"));
    started = true;
    resetGame(ws, wd);
  });

  setDemoScreenState();
  render();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>


