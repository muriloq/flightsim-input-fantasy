<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FlightRTSim – C++ Flight Model (HTML5)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#000; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { max-width: 980px; margin:0 auto; padding:16px; display:grid; gap:12px; }
    .panel { background:#000; border:1px solid #444; border-radius:10px; padding:12px; }
    label { display:block; margin:8px 0 4px; }
    input { width:170px; padding:6px 8px; background:#050505; border:1px solid #777; border-radius:6px; color:#fff; }
    button { padding:8px 10px; border-radius:8px; border:1px solid #999; background:#111; color:#fff; cursor:pointer; }
    button:hover { background:#222; }
    canvas { display:block; width:100%; height:auto; image-rendering: pixelated; background:#000; border:1px solid #fff; border-radius:4px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:end; }
    .hint { margin-top:8px; font-size:0.95rem; opacity:0.95; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:1px 6px; border:1px solid #777; border-radius:6px; background:#111; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="row">
        <div>
          <label>Velocidade do vento (1–50 m/s)</label>
          <input id="windSpeed" type="number" min="1" max="50" value="10" />
        </div>
        <div>
          <label>Direção do vento (0–359 graus)</label>
          <input id="windDir" type="number" min="0" max="359" value="0" />
        </div>
        <div>
          <button id="startBtn">Iniciar voo</button>
        </div>
      </div>
      <div class="hint">
        Controles:
        <span class="kbd">Q</span>/<span class="kbd">E</span> potência,
        <span class="kbd">A</span>/<span class="kbd">D</span> rolagem,
        <span class="kbd">W</span>/<span class="kbd">S</span> arfagem (invertido),
        <span class="kbd">Z</span>/<span class="kbd">C</span> leme,
        <span class="kbd">B</span> freio.
        No fim: <span class="kbd">S</span> novo voo, <span class="kbd">N</span> parar.
      </div>
    </div>

    <canvas id="screen" width="256" height="192" aria-label="Tela do simulador"></canvas>
  </div>

<script>
(() => {
  const W = 256, H = 192;
  const canvas = document.getElementById("screen");
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = false;

  const PI = Math.PI;
  const C = PI / 180;

  const SIM_HZ = 60;
  const DT = 1 / SIM_HZ;
  const MAX_CATCHUP_STEPS = 6;

  // --- Unit conversions (C++ model tuning is imperial-ish) ---
  const FT_TO_M = 0.3048;
  const M_TO_FT = 1 / FT_TO_M;
  const MPH_TO_MPS = 0.44704;
  const MPS_TO_MPH = 1 / MPH_TO_MPS;

  // --- Control effectiveness tuning (ported model was tuned for a different sim/context) ---
  // Lower values = slower response.
  // Requested tuning: elevator 2x slower, ailerons 5x slower (relative to previous values).
  const AILERON_GAIN = 0.4;   // 2.0 / 5
  const ELEVATOR_GAIN = 0.75; // 1.5 / 2
  const RUDDER_GAIN = 0.35;   // reduce yaw authority from rudder (Z/C)

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const wrap360 = (deg) => {
    deg %= 360;
    if (deg < 0) deg += 360;
    return deg;
  };
  const sgn = (x) => (x < 0 ? -1 : x > 0 ? 1 : 0);
  const rnd = (x) => Math.round(x);

  function clearScreen() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);
  }
  function line(x1, y1, x2, y2) {
    x1 = rnd(x1); y1 = rnd(y1);
    x2 = rnd(x2); y2 = rnd(y2);
    ctx.beginPath();
    ctx.moveTo(x1 + 0.5, y1 + 0.5);
    ctx.lineTo(x2 + 0.5, y2 + 0.5);
    ctx.stroke();
  }
  function circle(cx, cy, r) {
    cx = rnd(cx); cy = rnd(cy);
    ctx.beginPath();
    ctx.arc(cx + 0.5, cy + 0.5, r, 0, Math.PI * 2);
    ctx.stroke();
  }
  function needle(cx, cy, len, aRad) {
    const x2 = cx + len * Math.sin(aRad);
    const y2 = cy - len * Math.cos(aRad);
    line(cx, cy, x2, y2);
  }
  function textCentered(cx, y, s) {
    const w = ctx.measureText(s).width;
    ctx.fillText(s, rnd(cx - w / 2), rnd(y));
  }

  // Liang–Barsky line clipping
  function clipLineToRect(x1, y1, x2, y2, rx, ry, rw, rh) {
    let t0 = 0, t1 = 1;
    const dx = x2 - x1, dy = y2 - y1;
    function clip(p, q) {
      if (p === 0) return q >= 0;
      const r = q / p;
      if (p < 0) { if (r > t1) return false; if (r > t0) t0 = r; }
      else       { if (r < t0) return false; if (r < t1) t1 = r; }
      return true;
    }
    if (
      clip(-dx, x1 - rx) &&
      clip( dx, (rx + rw) - x1) &&
      clip(-dy, y1 - ry) &&
      clip( dy, (ry + rh) - y1)
    ) {
      const nx1 = x1 + t0 * dx, ny1 = y1 + t0 * dy;
      const nx2 = x1 + t1 * dx, ny2 = y1 + t1 * dy;
      return [nx1, ny1, nx2, ny2];
    }
    return null;
  }

  // Polygon clipping (Sutherland–Hodgman) against axis-aligned rectangle
  function clipPolygonRect(poly, xmin, xmax, ymin, ymax) {
    function clipEdge(points, insideFn, intersectFn) {
      const out = [];
      if (!points.length) return out;
      let S = points[points.length - 1];
      for (const E of points) {
        const Ein = insideFn(E);
        const Sin = insideFn(S);
        if (Ein) {
          if (!Sin) out.push(intersectFn(S, E));
          out.push(E);
        } else if (Sin) {
          out.push(intersectFn(S, E));
        }
        S = E;
      }
      return out;
    }

    function intersectX(p1, p2, x) {
      const [x1,y1] = p1, [x2,y2] = p2;
      const dx = x2 - x1;
      if (dx === 0) return [x, y1];
      const t = (x - x1) / dx;
      return [x, y1 + t * (y2 - y1)];
    }
    function intersectY(p1, p2, y) {
      const [x1,y1] = p1, [x2,y2] = p2;
      const dy = y2 - y1;
      if (dy === 0) return [x1, y];
      const t = (y - y1) / dy;
      return [x1 + t * (x2 - x1), y];
    }

    let out = poly.slice();
    out = clipEdge(out, p => p[0] >= xmin, (s,e) => intersectX(s,e,xmin));
    out = clipEdge(out, p => p[0] <= xmax, (s,e) => intersectX(s,e,xmax));
    out = clipEdge(out, p => p[1] >= ymin, (s,e) => intersectY(s,e,ymin));
    out = clipEdge(out, p => p[1] <= ymax, (s,e) => intersectY(s,e,ymax));
    return out;
  }

  function drawPolygon(poly) {
    if (!poly || poly.length < 2) return;
    for (let i = 0; i < poly.length; i++) {
      const a = poly[i];
      const b = poly[(i + 1) % poly.length];
      line(a[0], a[1], b[0], b[1]);
    }
  }

  // --- Minimal 3D camera (world meters) for the top window ---
  function v3(x, y, z) { return { x, y, z }; }
  function v3sub(a, b) { return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }; }
  function v3add(a, b) { return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }; }
  function v3mul(a, s) { return { x: a.x * s, y: a.y * s, z: a.z * s }; }
  function v3dot(a, b) { return a.x * b.x + a.y * b.y + a.z * b.z; }

  function computeCameraBasis(yawDeg, pitchNoseUpDeg, rollDeg) {
    // World axes: +X right, +Y forward, +Z up. Camera axes: +x right, +y down, +z forward.
    const psi = yawDeg * C;
    const th = pitchNoseUpDeg * C;
    const ph = rollDeg * C;

    // Start at level flight heading +Y.
    let f = v3(Math.sin(psi), Math.cos(psi), 0);
    let r = v3(Math.cos(psi), -Math.sin(psi), 0);
    let u = v3(0, 0, 1);

    // Pitch about right axis (nose up positive).
    {
      const f0 = f, u0 = u;
      f = v3add(v3mul(f0, Math.cos(th)), v3mul(u0, Math.sin(th)));
      u = v3add(v3mul(u0, Math.cos(th)), v3mul(f0, -Math.sin(th)));
    }

    // Roll about forward axis.
    const r2 = v3add(v3mul(r, Math.cos(ph)), v3mul(u, Math.sin(ph)));
    const u2 = v3add(v3mul(u, Math.cos(ph)), v3mul(r, -Math.sin(ph)));
    r = r2; u = u2;

    return { camRight: r, camDown: v3mul(u, -1), camFwd: f };
  }

  function worldToCamera(pWorld, camPos, basis) {
    const rel = v3sub(pWorld, camPos);
    return v3(
      v3dot(rel, basis.camRight),
      v3dot(rel, basis.camDown),
      v3dot(rel, basis.camFwd)
    );
  }

  function clipSegmentToNearPlane(p1, p2, nearZ) {
    // Keep z >= nearZ
    const z1 = p1.z, z2 = p2.z;
    const in1 = z1 >= nearZ, in2 = z2 >= nearZ;
    if (in1 && in2) return [p1, p2];
    if (!in1 && !in2) return null;
    const t = (nearZ - z1) / (z2 - z1);
    const pi = v3add(p1, v3mul(v3sub(p2, p1), t));
    if (!in1) return [pi, p2];
    return [p1, pi];
  }

  function clipPolygonToNearPlane(polyCam, nearZ) {
    // Sutherland–Hodgman in camera space, keep z >= nearZ
    const out = [];
    if (!polyCam || polyCam.length < 3) return out;
    let S = polyCam[polyCam.length - 1];
    const Sin = S.z >= nearZ;
    let SinFlag = Sin;
    for (const E of polyCam) {
      const EinFlag = E.z >= nearZ;
      if (EinFlag) {
        if (!SinFlag) {
          const t = (nearZ - S.z) / (E.z - S.z);
          out.push(v3add(S, v3mul(v3sub(E, S), t)));
        }
        out.push(E);
      } else if (SinFlag) {
        const t = (nearZ - S.z) / (E.z - S.z);
        out.push(v3add(S, v3mul(v3sub(E, S), t)));
      }
      S = E;
      SinFlag = EinFlag;
    }
    return out;
  }

  function projectCamToScreen(pCam, intr) {
    if (pCam.z <= intr.nearZ) return null;
    const x = intr.cx + intr.f * (pCam.x / pCam.z);
    const y = intr.cy + intr.f * (pCam.y / pCam.z);
    if (!isFinite(x) || !isFinite(y)) return null;
    return [x, y];
  }

  function lineRectIntersections(A, B, Cc, xmin, xmax, ymin, ymax) {
    // Line: A*x + B*y + Cc = 0. Return up to 2 unique points on the rectangle boundary.
    const pts = [];
    const eps = 1e-9;
    function addPt(x, y) {
      if (!isFinite(x) || !isFinite(y)) return;
      if (x < xmin - 1e-6 || x > xmax + 1e-6 || y < ymin - 1e-6 || y > ymax + 1e-6) return;
      for (const p of pts) {
        if (Math.abs(p[0] - x) < 0.25 && Math.abs(p[1] - y) < 0.25) return;
      }
      pts.push([x, y]);
    }

    // x = xmin/xmax -> solve for y
    if (Math.abs(B) > eps) {
      addPt(xmin, -(A * xmin + Cc) / B);
      addPt(xmax, -(A * xmax + Cc) / B);
    }
    // y = ymin/ymax -> solve for x
    if (Math.abs(A) > eps) {
      addPt(-(B * ymin + Cc) / A, ymin);
      addPt(-(B * ymax + Cc) / A, ymax);
    }
    if (pts.length <= 2) return pts;
    // If we got more due to corner hits, keep the two farthest apart
    let best = [pts[0], pts[1]];
    let bestD = -1;
    for (let i = 0; i < pts.length; i++) {
      for (let j = i + 1; j < pts.length; j++) {
        const dx = pts[i][0] - pts[j][0];
        const dy = pts[i][1] - pts[j][1];
        const d = dx * dx + dy * dy;
        if (d > bestD) { bestD = d; best = [pts[i], pts[j]]; }
      }
    }
    return best;
  }

  // --- Game state ---
  let running = false;
  let ended = false;
  let started = false;
  let endMessage = [];

  // Landing-game coordinates (metric)
  let PX = 0, PY = 0, PZ = 0; // meters; PZ is altitude above runway plane
  let VX = 0, VY = 0, VZ = 0; // m/s (derived from flight model)
  let GX = 0, GY = 0, GZ = 0; // m/s with wind
  let AD = 0;                 // heading degrees (0..360)

  // Wind (metric, m/s)
  let WX = 0, WY = 0;

  // --- C++ flight-model state (ported) ---
  // Control surfaces (reduced indices, -15..+15)
  let aileron_pos = 0;
  let elevator_pos = 0;
  let rudder_pos = 0;
  let brake = true;

  // Engine / power
  let ignition_on = true;
  let engine_on = true;
  let throttle_pos = 0; // scaled from TC for C++ formulas
  let rpm = 0;

  // Attitude (degrees)
  let roll = 0;
  let pitch = 0;
  let yaw = 0; // degrees, mapped to AD

  // Speeds tuned like C++ (mostly mph and feet-per-loop)
  let h_speed_mph = 0;       // horizontal speed (mph)
  let v_speed_ft = 0;        // vertical displacement per loop (feet/loop)
  let delta_z_ft = 0;        // forward displacement per loop (feet/loop)
  let efAOF_rad = 0;         // effective angle of flight (radians)
  let stall = false;
  let airborne = true;

  // Rotational deltas (degrees per loop; C++ labels deg/ms but applies as deg/loop)
  const deltaVect = { dPitch: 0, dYaw: 0, dRoll: 0 };

  // User-facing throttle knob (kept for RPM dial behavior)
  let TC = 5; // 0.2..8.8

  const RT = 3, TP = 5, WR = 50; // landing thresholds: roll, pitch, runway half-width (meters)

  // Runway model used by the renderer/instruments (world meters).
  // The 3D runway drawing uses a strip starting at Y=0 (touchdown threshold)
  // extending forward (+Y). Instruments should reference the same runway geometry.
  const RUNWAY_START_Y = 0;
  const RUNWAY_LEN_M = 3000;
  const RUNWAY_END_Y = RUNWAY_START_Y + RUNWAY_LEN_M;
  const RUNWAY_REF_Y = RUNWAY_START_Y + RUNWAY_LEN_M * 0.5; // instrument reference point on runway

  const keysDown = new Set();
  let bWasDown = false;

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    // End screen choices: ignore repeats so holding a key won't restart instantly.
    if (ended && (k === "s" || k === "n")) {
      if (e.repeat) return;
      if (k === "s") document.getElementById("startBtn").click();
      else if (k === "n") {
        running = false;
        ended = true;
        endMessage = ["Encerrado.", "Recarregue a página para jogar novamente."];
      }
      return;
    }

    keysDown.add(k);
  });
  window.addEventListener("keyup", (e) => keysDown.delete(e.key.toLowerCase()));

  function setDemoScreenState() {
    running = false;
    ended = false;
    endMessage = [];
    PX = 0; PY = 0; PZ = 0;
    VX = 0; VY = 0; VZ = 0;
    GX = 0; GY = 0; GZ = 0;
    AD = 0;
    WX = 0; WY = 0;

    aileron_pos = 0;
    elevator_pos = 0;
    rudder_pos = 0;
    brake = true;
    ignition_on = true;
    engine_on = true;
    throttle_pos = 0;
    rpm = 0;
    roll = 0;
    pitch = 0;
    yaw = 0;
    h_speed_mph = 0;
    v_speed_ft = 0;
    delta_z_ft = 0;
    efAOF_rad = 0;
    stall = false;
    airborne = true;
    deltaVect.dPitch = deltaVect.dYaw = deltaVect.dRoll = 0;
    TC = 5;

    bWasDown = false;
    keysDown.clear();
  }

  function resetGame(windSpeed, windDir) {
    ended = false;
    endMessage = [];
    keysDown.clear();

    // Start position (metric)
    PX = 0;
    PY = -10000;
    PZ = 1500;

    // Start attitude
    roll = 0;
    pitch = 0;
    yaw = 0;
    AD = 0;

    // Start throttle / engine
    TC = 5;
    ignition_on = true;
    engine_on = true;

    // Start speed: match previous game feel (150 m/s) but keep C++ mph state.
    h_speed_mph = 150 * MPS_TO_MPH;

    // Initialize rpm near nominal for TC
    throttle_pos = clamp(TC * 8.5, 0, 75);
    rpm = 375 + throttle_pos * 117;

    // Wind scaling from original BASIC: windSpeed/3
    const X0 = windSpeed / 3;
    const X1 = windDir;
    WY = X0 * Math.cos(X1 * C);
    WX = -X0 * Math.sin(X1 * C);

    // Controls reset
    aileron_pos = 0;
    elevator_pos = 0;
    rudder_pos = 0;
    brake = false;
    stall = false;
    airborne = true;
    deltaVect.dPitch = deltaVect.dYaw = deltaVect.dRoll = 0;
    v_speed_ft = 0;
    delta_z_ft = 0;
    efAOF_rad = 0;

    running = true;
  }

  function rads(deg) {
    if (deg < 0) deg += 360;
    return deg * C;
  }
  function degs(rad) {
    return rad / C;
  }

  function updateControls(dt) {
    // Throttle change is time-based. Preserve ~0.2 per tick @60Hz feel.
    const TC_RATE = 12.0;
    if (keysDown.has("q")) TC += TC_RATE * dt;
    if (keysDown.has("e")) TC -= TC_RATE * dt;
    TC = clamp(TC, 0.2, 8.8);

    // Toggle brakes (edge-triggered)
    const bDown = keysDown.has("b");
    if (bDown && !bWasDown) brake = !brake;
    bWasDown = bDown;

    // Roll: A/D
    let rollIn = 0;
    if (keysDown.has("a")) rollIn -= 1;
    if (keysDown.has("d")) rollIn += 1;

    // Pitch: W nose up, S nose down (inverted compared to the prior mapping).
    let pitchIn = 0;
    if (keysDown.has("w")) pitchIn += 1;
    if (keysDown.has("s")) pitchIn -= 1;

    // Rudder: Z/C
    let rudderIn = 0;
    if (keysDown.has("z")) rudderIn += 1;
    if (keysDown.has("c")) rudderIn -= 1;

    // Control surfaces: self-centering with a smooth first-order response.
    // The straight port that *integrates* surface position can "wind up" and
    // keep rolling/looping even after keys are released. This makes the sim
    // far more controllable while still using the C++ dynamics core.
    const AIL_TARGET = rollIn * 15;
    const ELE_TARGET = pitchIn * 15;
    // Rudder gets a smaller target deflection to keep yaw more manageable.
    const RUD_TARGET = rudderIn * 8;
    const SURF_RESP = 5.0; // 1/s (lower = slower to respond and slower to return to center)
    const alpha = 1 - Math.exp(-SURF_RESP * dt);
    aileron_pos = clamp(aileron_pos + (AIL_TARGET - aileron_pos) * alpha, -15, 15);
    elevator_pos = clamp(elevator_pos + (ELE_TARGET - elevator_pos) * alpha, -15, 15);

    rudder_pos = clamp(rudder_pos + (RUD_TARGET - rudder_pos) * alpha, -15, 15);

    // Throttle position for C++ formulas (0..~75)
    throttle_pos = clamp(TC * 8.5, 0, 75);
  }

  function calcPowerDyn(loopTimeMs) {
    if (ignition_on) {
      if (!engine_on) engine_on = true;
      const nominal = 375 + (throttle_pos * 117);
      if (rpm < nominal) rpm += loopTimeMs * 0.5;
      if (rpm > nominal) rpm -= loopTimeMs * 0.5;
    } else {
      if (engine_on) engine_on = false;
      if (rpm) rpm -= (loopTimeMs / 2);
    }
    if (rpm < 0) rpm = 0;
  }

  function calcFlightDyn(loopTimeMs) {
    // Port of AirCraft::CalcFlightDyn with the same tuning assumptions.
    let iSpeed = rpm / 17.5;
    iSpeed += (pitch * 1.5);

    let hAccel = ((rpm * (iSpeed - h_speed_mph)) / 10000);
    hAccel /= 1000;
    hAccel *= loopTimeMs;

    if (brake && !airborne) {
      if (h_speed_mph > 0) h_speed_mph -= 1;
      else h_speed_mph = 0;
    } else {
      h_speed_mph += hAccel;
    }

    // Lift curve
    let lSpeed = (h_speed_mph / 65) - 1;
    if (lSpeed > 1) lSpeed = 1;
    let lVeloc = degs(Math.atan(lSpeed));
    lVeloc += 45;
    lVeloc /= 5.29;
    lVeloc *= (-(pitch * 0.157) + 1);
    lVeloc /= 1000;
    lVeloc *= loopTimeMs;

    // Gravity term (C++ uses -16 ft/sec)
    const GRAV_C_FTPS = -16.0;
    const gVeloc = loopTimeMs * (GRAV_C_FTPS / 1000);
    v_speed_ft = gVeloc + lVeloc;
    if ((!airborne) && (v_speed_ft < 0)) v_speed_ft = 0;

    // Forward displacement from mph
    delta_z_ft = h_speed_mph * 5280;
    delta_z_ft /= 3600000;
    delta_z_ft *= loopTimeMs;

    // Effective angle of flight
    if (delta_z_ft) efAOF_rad = -(Math.atan(v_speed_ft / delta_z_ft));
    else efAOF_rad = -(Math.atan(v_speed_ft));

    const AOA = degs(efAOF_rad);

    // Stall logic (ported)
    if (((pitch < AOA) && (AOA < 0)) && (h_speed_mph < 40)) {
      if ((pitch - AOA) < -20) stall = true;
    }
    if (stall) {
      if (pitch > 30) stall = false;
      else pitch++;
    }
  }

  function inertialDamp() {
    if (deltaVect.dPitch) {
      deltaVect.dPitch -= deltaVect.dPitch / 10;
      if (((deltaVect.dPitch > 0) && (deltaVect.dPitch < 0.01)) ||
          ((deltaVect.dPitch < 0) && (deltaVect.dPitch > -0.01))) {
        deltaVect.dPitch = 0;
      }
    }
    if (deltaVect.dYaw) {
      deltaVect.dYaw -= deltaVect.dYaw / 10;
      if (((deltaVect.dYaw > 0) && (deltaVect.dYaw < 0.01)) ||
          ((deltaVect.dYaw < 0) && (deltaVect.dYaw > -0.01))) {
        deltaVect.dYaw = 0;
      }
    }
    if (deltaVect.dRoll) {
      deltaVect.dRoll -= deltaVect.dRoll / 10;
      if (((deltaVect.dRoll > 0) && (deltaVect.dRoll < 0.01)) ||
          ((deltaVect.dRoll < 0) && (deltaVect.dRoll > -0.01))) {
        deltaVect.dRoll = 0;
      }
    }
  }

  function calcTurnRate() {
    let torque = 0.0;
    if ((roll > 0) && (roll <= 90)) torque = (roll * 0.00050);
    else if ((roll < 0) && (roll >= -90)) torque = (roll * 0.00050);
    return torque;
  }

  function calcROC(loopTimeMs) {
    let torque;
    if (airborne) {
      if (aileron_pos !== 0) {
        torque = ((h_speed_mph * aileron_pos) / 10000);
        if (deltaVect.dRoll !== (torque * loopTimeMs)) deltaVect.dRoll += torque * AILERON_GAIN;
      }
    }
    if (elevator_pos !== 0) {
      torque = ((h_speed_mph * elevator_pos) / 10000);
      if ((!airborne) && (torque > 0)) torque = 0;
      if (deltaVect.dPitch !== (torque * loopTimeMs)) deltaVect.dPitch += torque * ELEVATOR_GAIN;
    }
    if (h_speed_mph) {
      torque = 0.0;
      if (rudder_pos !== 0) torque = -((h_speed_mph * rudder_pos) / 10000) * RUDDER_GAIN;
      torque += calcTurnRate();
      if (deltaVect.dYaw !== (torque * loopTimeMs)) deltaVect.dYaw += torque * 1.5;
    }

    // Hard caps on angular deltas (deg per simulation step) to prevent runaway rates
    // in the discrete-time port.
    deltaVect.dRoll  = clamp(deltaVect.dRoll,  -1.2, 1.2);
    deltaVect.dPitch = clamp(deltaVect.dPitch, -1.0, 1.0);
    deltaVect.dYaw   = clamp(deltaVect.dYaw,   -1.2, 1.2);
  }

  function applyRots() {
    roll += deltaVect.dRoll;
    yaw += deltaVect.dYaw;
    pitch += (deltaVect.dPitch * Math.cos(rads(roll)));
    yaw += -(deltaVect.dPitch * Math.sin(rads(roll)));

    // bounds roll/yaw to [-180..180]
    if (roll > 180) roll = -180 + (roll - 180);
    else if (roll < -180) roll = 180 + (roll + 180);
    if (yaw > 180) yaw = -180 + (yaw - 180);
    else if (yaw < -180) yaw = 180 + (yaw + 180);

    // special case pitch past vertical
    if ((pitch > 90) || (pitch < -90)) {
      if (roll >= 0) roll -= 180;
      else roll += 180;
      if (yaw >= 0) yaw -= 180;
      else yaw += 180;
      if (pitch > 0) pitch = (180 - pitch);
      else pitch = (-180 - pitch);
    }

    // damp close to zero
    if ((pitch > -0.5) && (pitch < 0.5)) pitch = 0;
    if ((roll > -0.5) && (roll < 0.5)) roll = 0;
    if ((yaw > -0.5) && (yaw < 0.5)) yaw = 0;
  }

  function integratePosition(loopTimeMs) {
    // Port the simplified rotation path in RunFModel (roll rotation omitted in v2.1).
    const tmpZ = delta_z_ft;

    // Rotate in X by effective angle of flight
    const newY_ft = -(tmpZ * Math.sin(efAOF_rad));
    const newZ_ft = (tmpZ * Math.cos(efAOF_rad));

    // Rotate in Y by yaw
    const yawRad = rads(yaw);
    const dX_ft = (newZ_ft * Math.sin(yawRad));
    const dFwd_ft = (newZ_ft * Math.cos(yawRad));

    // Apply to metric positions. Signs follow the C++ convention (x_pos -=, z_pos +=).
    PX -= dX_ft * FT_TO_M;
    PY += dFwd_ft * FT_TO_M;
    PZ += newY_ft * FT_TO_M;

    // Update heading for UI
    AD = wrap360(yaw < 0 ? yaw + 360 : yaw);

    // Airborne flag (simple): becomes airborne once altitude > 0
    if ((!airborne) && (PZ > 0)) airborne = true;
  }

  function stepPhysics(dt) {
    const loopTimeMs = Math.max(1, dt * 1000);

    // C++ ordering: power/flight dynamics, damping, ROC, apply rotations, integrate.
    calcPowerDyn(loopTimeMs);
    calcFlightDyn(loopTimeMs);
    inertialDamp();
    calcROC(loopTimeMs);
    applyRots();
    integratePosition(loopTimeMs);

    // Derive velocities for wind + instruments from current state
    const speedMps = Math.max(0, h_speed_mph * MPH_TO_MPS);
    const ra = AD * C;
    VX = speedMps * Math.sin(ra);
    VY = speedMps * Math.cos(ra);
    VZ = v_speed_ft * FT_TO_M / dt; // ft/loop -> m/s (approx; avoids re-deriving from efAOF)

    GX = VX + WX;
    GY = VY + WY;
    GZ = VZ;

    // Integrate wind drift using metric velocities (keeps old UI behavior).
    // Note: primary position integration already happened via C++ model (still-air).
    PX += WX * dt;
    PY += WY * dt;

    // Ground contact => finish
    if (PZ <= 0) {
      PZ = 0;
      finishLanding();
    }
  }

  function finishLanding() {
    keysDown.clear();
    running = false;
    ended = true;

    // Distance to runway reference point (meters). Keeps DRIFT and DISTANCE consistent:
    // DISTANCE is always >= |DRIFT|.
    const dxr = PX;
    const dyr = PY - RUNWAY_REF_Y;
    const dist = Math.sqrt(dxr*dxr + dyr*dyr);
    const vvMps = Math.max(0, h_speed_mph * MPH_TO_MPS);

    // Reuse original scoring thresholds (tuned for the landing mini-game).
    if (Math.abs(roll) > RT || pitch > TP || pitch < 0 || vvMps > 80) {
      endMessage = [
        "LAMENTAMOS INFORMAR QUE O VOO PJ26 SOFREU UM GRAVE ACIDENTE.",
        "NAO HA SOBREVIVENTES."
      ];
    } else if (Math.abs(PX) > WR || Math.abs(PY) > 1000) {
      if (vvMps < 40) endMessage = ["VOCE POUSOU FORA DA PISTA.", "COMO SUA VELOCIDADE ERA BAIXA,",
        " QUASE NADA ACONTECEU."];
      else if (vvMps < 80) endMessage = ["VOCE POUSOU FORA DA PISTA.", "ENTRE MORTOS E FERIDOS,",
        " SALVARAM-SE TODOS."];
      else endMessage = ["VOCE POUSOU FORA DA PISTA.", "NINGUEM SOBREVIVE A UM POUSO",
        " NESTA VELOCIDADE."];
    } else {
      endMessage = ["PARABENS!", "ATERRISSAGEM BEM SUCEDIDA."];
    }

    endMessage.push("");
    endMessage.push("VALORES RELATIVOS AO POUSO:");
    endMessage.push(`VELOCIDADE DO AR = ${Math.floor(vvMps)} M/S`);
    endMessage.push(`DISTANCIA        = ${Math.floor(dist)} M`);
    endMessage.push(`INCLINACAO FRONTAL= ${Math.floor(pitch)}`);
    endMessage.push(`INCLINACAO LATERAL= ${Math.floor(roll)}`);
    endMessage.push(`ROTACAO DO MOTOR  = ${Math.floor(rpm)} RPM`);
    endMessage.push(`DESVIO DA PISTA   = ${Math.floor(PX)} M`);
    endMessage.push(`DIRECAO           = ${Math.floor(AD)} GRAUS`);
    endMessage.push("");
    endMessage.push("VOAR NOVAMENTE? (S/N)");
  }

  function computeRunwayBearingRB() {
    if (!started) return 0;
    // Bearing from aircraft to a runway reference point on the drawn runway strip.
    // Heading convention: 0° = +Y, clockwise positive, as used by the HUD.
    const dx = 0 - PX;
    const dy = RUNWAY_REF_Y - PY;
    if (dx === 0 && dy === 0) return 0;
    const RB = Math.atan2(dx, dy) / C;
    return wrap360(RB);
  }

  // --- TOP WINDOW ---
  function drawWindowAndRunway() {
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;

    line(10, 0, 245, 0);
    line(245, 0, 245, 80);
    line(245, 80, 10, 80);
    line(10, 80, 10, 0);

    const xmin = 16, xmax = 239, ymin = 1, ymax = 79;
    const vw = (xmax - xmin);
    const vh = (ymax - ymin);
    const intr = {
      cx: (xmin + xmax) * 0.5,
      cy: (ymin + ymax) * 0.5,
      f: (vw * 0.5) / Math.tan(60 * C * 0.5),
      nearZ: 1.0
    };

    // Camera pose: use aircraft position and attitude.
    // Model convention: pitch increases when pitching down, so invert to get "nose up".
    const camPos = v3(PX, PY, PZ);
    const basis = computeCameraBasis(AD, -pitch, roll);

    // Near plane: keep small. A large nearZ (like 1m) can slice the runway when low,
    // producing unstable polygons. We keep it small but non-zero to avoid blowups.
    intr.nearZ = Math.max(0.05, Math.min(0.2, camPos.z * 0.02));

    // Camera-correct horizon line: a*(X-cx)+b*(Y-cy)+c*f = 0
    // Keep coefficients so the ground-grid can extend up to the horizon.
    let horizonA = 0, horizonB = 0, horizonC = 0;
    {
      const worldUp = v3(0, 0, 1);
      const a = v3dot(basis.camRight, worldUp);
      const b = v3dot(basis.camDown, worldUp);
      const c = v3dot(basis.camFwd, worldUp);
      const A = a;
      const B = b;
      const Cc = c * intr.f - a * intr.cx - b * intr.cy;
      horizonA = A; horizonB = B; horizonC = Cc;
      const pts = lineRectIntersections(A, B, Cc, xmin, xmax, ymin, ymax);
      if (pts.length === 2) line(pts[0][0], pts[0][1], pts[1][0], pts[1][1]);
    }

    if (!started) return;

    // --- Ground grid (500m spacing) on Z=0 ---
    ctx.strokeStyle = "#666";
    const GRID = 500;

    function screenRayDirWorld(x, y) {
      // Camera ray through pixel (x,y). Camera coordinates: z forward, y down.
      const dx = (x - intr.cx) / intr.f;
      const dy = (y - intr.cy) / intr.f;
      // World dir = camRight*dx + camDown*dy + camFwd*1
      return v3add(v3add(v3mul(basis.camRight, dx), v3mul(basis.camDown, dy)), basis.camFwd);
    }

    function intersectRayWithGroundZ0(dirWorld) {
      // Ray: camPos + t*dirWorld, ground plane z=0.
      const eps = 1e-9;
      if (dirWorld.z >= -eps) return null; // not pointing toward ground
      const t = (0 - camPos.z) / dirWorld.z;
      if (!isFinite(t) || t <= 0) return null;
      return v3add(camPos, v3mul(dirWorld, t));
    }

    // Find a y coordinate just below the horizon (at screen center).
    let yH = null;
    if (Math.abs(horizonB) > 1e-9) {
      yH = -(horizonA * intr.cx + horizonC) / horizonB;
    }
    const ySample = clamp((yH == null ? intr.cy : (yH + 1)), ymin, ymax);

    // Estimate "visible-to-horizon" ground distance by intersecting a few rays
    // just below the horizon and at the bottom of the viewport.
    const samplePts = [
      [xmin, ySample],
      [intr.cx, ySample],
      [xmax, ySample],
      [xmin, ymax],
      [intr.cx, ymax],
      [xmax, ymax],
    ];
    let farDist = 0;
    for (const [sx, sy] of samplePts) {
      const hit = intersectRayWithGroundZ0(screenRayDirWorld(sx, sy));
      if (!hit) continue;
      const d = Math.hypot(hit.x - PX, hit.y - PY);
      if (isFinite(d) && d > farDist) farDist = d;
    }
    // Safety margins & caps (avoid huge line counts while still reaching the horizon visually).
    farDist = Math.min(Math.max(farDist * 1.15, 3000), 250000);

    // Also ensure the grid spans at least twice the distance to the runway (origin).
    const distToRunway = Math.hypot(PX, PY);
    const RANGE = Math.max(farDist, 2 * distToRunway);

    const x0 = Math.floor((PX - RANGE) / GRID) * GRID;
    const x1 = Math.ceil((PX + RANGE) / GRID) * GRID;
    const y0 = Math.floor((PY - RANGE) / GRID) * GRID;
    const y1 = Math.ceil((PY + RANGE) / GRID) * GRID;

    function drawWorldSegment(pw1, pw2) {
      let p1c = worldToCamera(pw1, camPos, basis);
      let p2c = worldToCamera(pw2, camPos, basis);
      const clipped = clipSegmentToNearPlane(p1c, p2c, intr.nearZ);
      if (!clipped) return;
      p1c = clipped[0]; p2c = clipped[1];
      const s1 = projectCamToScreen(p1c, intr);
      const s2 = projectCamToScreen(p2c, intr);
      if (!s1 || !s2) return;
      const seg = clipLineToRect(s1[0], s1[1], s2[0], s2[1], xmin, ymin, vw, vh);
      if (seg) line(seg[0], seg[1], seg[2], seg[3]);
    }

    for (let y = y0; y <= y1; y += GRID) {
      drawWorldSegment(v3(x0, y, 0), v3(x1, y, 0));
    }
    for (let x = x0; x <= x1; x += GRID) {
      drawWorldSegment(v3(x, y0, 0), v3(x, y1, 0));
    }

    // --- Runway as a true world rectangle on Z=0 ---
    // The landing game measures distance to the runway touchdown point at (0,0).
    // To keep the runway stable on approach (PY starts negative), define the runway
    // starting at Y=0 and extending forward (+Y), rather than centered at the origin.
    ctx.strokeStyle = "#fff";
    // (RUNWAY_START_Y / RUNWAY_END_Y are defined above)
    const rw = WR;
    const runwayWorld = [
      v3(-rw, RUNWAY_START_Y, 0),
      v3( rw, RUNWAY_START_Y, 0),
      v3( rw, RUNWAY_END_Y, 0),
      v3(-rw, RUNWAY_END_Y, 0),
    ];

    const runwayCam = runwayWorld.map(p => worldToCamera(p, camPos, basis));
    const runwayCamClipped = clipPolygonToNearPlane(runwayCam, intr.nearZ);
    if (runwayCamClipped.length >= 3) {
      const runwayScr = runwayCamClipped.map(p => projectCamToScreen(p, intr));
      // If any vertex failed projection (should be rare after near-plane clipping),
      // bail out rather than drawing a malformed polygon that can flicker.
      if (runwayScr.some(p => !p)) return;
      const runwayPoly = clipPolygonRect(runwayScr, xmin, xmax, ymin, ymax);
      if (runwayPoly.length >= 3) {
        // Mask the grid inside the runway by filling with background color.
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.moveTo(runwayPoly[0][0], runwayPoly[0][1]);
        for (let i = 1; i < runwayPoly.length; i++) ctx.lineTo(runwayPoly[i][0], runwayPoly[i][1]);
        ctx.closePath();
        ctx.fill();

        // Outline runway.
        ctx.strokeStyle = "#fff";
        drawPolygon(runwayPoly);

        // Centerline dashes (world space along runway center x=0)
        const dashStep = 100;
        const dashLen = 40;
        for (let yy = RUNWAY_START_Y; yy < RUNWAY_END_Y; yy += dashStep) {
          const a = v3(0, yy, 0);
          const b = v3(0, Math.min(RUNWAY_END_Y, yy + dashLen), 0);
          drawWorldSegment(a, b);
        }
      }
    }
  }

  // --- INSTRUMENTS ---
  function drawInstrumentsAndHUD() {
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;
    ctx.fillStyle = "#fff";

    const yDial = 128;
    const dials = [
      { cx: 35,  top: "AIRSPEED", bot: "BEARING"  },
      { cx: 95,  top: "HORIZ",    bot: "RUNWAY"   },
      { cx: 155, top: "ALTITUDE", bot: "DRIFT"    },
      { cx: 215, top: "RPM",      bot: "DISTANCE" },
    ];

    for (const d of dials) circle(d.cx, yDial, 25);
    for (const d of dials) {
      for (let k = 0; k < 10; k++) {
        const a = k * PI / 5;
        line(d.cx + 21 * Math.sin(a), yDial - 21 * Math.cos(a),
             d.cx + 19 * Math.sin(a), yDial - 19 * Math.cos(a));
      }
    }

    const yTopLabel  = 95;
    const yDialValue = 112;
    const yBotLabel  = 168;
    const yBotValue  = 180;

    ctx.font = "10px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    for (const d of dials) {
      textCentered(d.cx, yTopLabel, d.top);
      textCentered(d.cx, yBotLabel, d.bot);
    }

    const RB = started ? computeRunwayBearingRB() : 0;
    // Distance to runway reference point (meters)
    const dist = started ? Math.sqrt(PX*PX + (PY - RUNWAY_REF_Y)*(PY - RUNWAY_REF_Y)) : 0;

    const vvMps = Math.max(0, h_speed_mph * MPH_TO_MPS);

    ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    textCentered(35,  yDialValue, `${Math.floor(vvMps)}`);
    textCentered(155, yDialValue, `${Math.floor(PZ)}`);
    textCentered(215, yDialValue, `${Math.floor(rpm)}`);

    needle(35, yDial, 15, vvMps * PI / 200);

    // Horizon dial
    {
      const cx = 95, cy = yDial;
      const r = 18;
      const theta = -roll * 2 * C;
      const dx = Math.cos(theta), dy = Math.sin(theta);
      const uiPitch = -pitch;
      const x0 = cx, y0 = cy + uiPitch;

      const fx = x0 - cx, fy = y0 - cy;
      const b = 2 * (fx * dx + fy * dy);
      const cc = (fx * fx + fy * fy) - r * r;
      const disc = b * b - 4 * cc;
      if (disc >= 0) {
        const s = Math.sqrt(disc);
        const t1 = (-b - s) / 2;
        const t2 = (-b + s) / 2;
        line(x0 + t1 * dx, y0 + t1 * dy, x0 + t2 * dx, y0 + t2 * dy);
      }

      let x = 81, y = yDial;
      const segs = [[9,0],[5,5],[5,-5],[9,0]];
      for (const [sx, sy] of segs) {
        line(x, y, x + sx, y + sy);
        x += sx; y += sy;
      }
    }

    // Altitude needles (as in original)
    const TN = started ? (PZ / 1000) : 0;
    const UN = started ? (PZ - 1000 * Math.floor(TN)) : 0;
    needle(155, yDial, 10, TN * PI / 5);
    needle(155, yDial, 15, UN * PI / 500);

    // RPM needle (scaled to 0..~9000 mapped to 0..5*PI)
    needle(215, yDial, 15, clamp(rpm / 1800, 0, 5) * PI / 5);

    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    textCentered(35,  yBotValue, `${Math.floor(started ? AD : 0)}`);
    textCentered(95,  yBotValue, `${Math.floor(RB)}`);
    textCentered(155, yBotValue, `${Math.floor(started ? PX : 0)}`);
    textCentered(215, yBotValue, `${Math.floor(dist)}`);
  }

  function drawEndScreen() {
    ctx.fillStyle = "rgba(0,0,0,0.92)";
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = "#fff";
    ctx.font = "10px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    let y = 18;
    for (const s of endMessage) {
      if (s === "") { y += 6; continue; }
      ctx.fillText(s, 10, y);
      y += 12;
      if (y > H - 10) break;
    }
  }

  function render() {
    clearScreen();
    ctx.strokeStyle = "#fff";
    ctx.fillStyle = "#fff";
    drawWindowAndRunway();
    drawInstrumentsAndHUD();
    if (ended) drawEndScreen();
  }

  let last = performance.now();
  let acc = 0;

  function loop(now) {
    const dtReal = (now - last) / 1000;
    last = now;
    acc += Math.min(dtReal, 0.25);

    let steps = 0;
    while (acc >= DT && steps < MAX_CATCHUP_STEPS) {
      if (running && !ended) {
        updateControls(DT);
        stepPhysics(DT);
      }
      acc -= DT;
      steps++;
    }

    render();
    requestAnimationFrame(loop);
  }

  document.getElementById("startBtn").addEventListener("click", () => {
    const ws = clamp(parseFloat(document.getElementById("windSpeed").value || "10"), 1, 50);
    const wd = wrap360(parseFloat(document.getElementById("windDir").value || "0"));
    started = true;
    resetGame(ws, wd);
  });

  setDemoScreenState();
  render();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>


